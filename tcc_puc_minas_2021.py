# -*- coding: utf-8 -*-
"""TCC-PUC Minas (2021.v.final).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hUV0ekuudrhan4SZgWEf0CsaK7FABAPF

# üìöTCC PUC - Ci√™ncia de Dados e Big Data

# üìùSum√°rio



1.  üìç Defini√ß√£o do Problema

2.  üìç Coleta de dados

> ‚öôÔ∏èExtra√ß√£o dos dados e tratamento
```
*   FONTE 1---| Casos e √ìbitos - Por Munic√≠pio e Data |
*   FONTE 2---| Casos e √ìbitos - Por Munic√≠pio e Ra√ßa/Cor |
*   FONTE 3---| Rela√ß√£o de GVE e DRS |
*   FONTE 4---| Lista de Municipio da GeoBr - *Multi-Polygon* |
```

> üîÄLinkage / Joins / Cruzamentos
```
*   JOIN 1---| Enriquecimento da Fonte-3 com a Fonte-4 |
*   JOIN 2---| Enriquecimento da Fonte-1 com o Join-1  |
*   JOIN 3---| Enriquecimento da Fonte-2 com o Join-1  |
```

3.  üìç An√°lise e Explora√ß√£o dos dados

> üìäCASOS
```
*   An√°lise 1---| Linha hist√≥rica |
*   An√°lise 2---| Sexo            |
*   An√°lise 3---| Ra√ßa/Cor        |
*   An√°lise 4---| Idade           |
*   An√°lise 5---| Por Municipio   |
*   An√°lise 6---| Por GVE         |
*   An√°lise 7---| Por DRS         |
```

> üìä√ìBITOS
```
*   An√°lise 1---| Linha hist√≥rica |
*   An√°lise 2---| Sexo            |
*   An√°lise 3---| Ra√ßa/Cor        |
*   An√°lise 4---| Idade           |
*   An√°lise 5---| Por Municipio   |
*   An√°lise 6---| Por GVE         |
*   An√°lise 7---| Por DRS         |
```

> üìäCASOS x √ìBITOS
```
*   An√°lise 1---| Linha hist√≥rica |
*   An√°lise 2---| Por Municipio   |
*   An√°lise 3---| Por GVE         |
*   An√°lise 4---| Por DRS         |
```

> üåçMAPAS
```
*   An√°lise 1---| CASOS |
*   An√°lise 2---| OBITOS |
```

4.  üìç Modelos de Machine Learning

> ‚ñ∂Ô∏èFEATURES
```
> ‚ñ∂Ô∏èPREPARAR DADOS PARA PRIMEIRO ENSAIO
> ‚ñ∂Ô∏èInvervalos
> ‚ñ∂Ô∏èTratamento de valores ausentes
> ‚ñ∂Ô∏èEngenharia de Features
> ‚ñ∂Ô∏èEvitar Data Leakage
```
> ‚ñ∂Ô∏èTIPOS DE MODELOS
```
*   1-Auto-Arima (v.1)
*   1-Auto-Arima (v.2)
*   2-Curva exponencial
*   3-Curva Gaussiana
*   4-Gaussian Naive Bayes
*   5-Prophet (v.1)
*   5-Prophet (v.1)
*   6-Regress√£o Linear
*   7-Suaviza√ß√£o Exponencial (Holt-Winters)
*   8-XGBoost
*   9-LightGBM
```
> ‚ñ∂Ô∏èMODELO ESCOLHIDO
```
*   10-SIGMOID (v.1)
*   10-SIGMOID (v.2)
*   10-LSTM com camada SIGMOID
*   10-SIGMOID (v.3)
```

# üìç1.Defini√ß√£o do Problema

Ser√° feita uma coleta e an√°lise de dados referente aos casos e √≥bitos de COVID-19 no Estado de S√£o Paulo.

O objetivo √© fornecer um modelo de previs√£o √∫til para monitorar regi√µes com maior probabilidade de ocorrer surtos ou endemias do v√≠rus, possibilitando ajudar a melhorar a qualidade do atendimento aos pacientes, reduzir as complica√ß√µes e mortalidade relacionadas ao COVID-19, al√©m claro de apoiar a tomada de decis√µes informadas em n√≠vel estadual e municipal.

O modelo pode ajudar a orientar pol√≠ticas p√∫blicas relacionadas ao COVID-19 a longo prazo, fornecendo informa√ß√µes valiosas sobre as popula√ß√µes mais vulner√°veis e orientando a aloca√ß√£o de recursos de sa√∫de por munic√≠pio.

Os dados ser√£o tratados e trabalhados e posteriormente aplicaremos algoritmos Machine Learning para realizar previs√µes para o Estado de S√£o Paulo e seus 645 munic√≠pios, divididos por DRS e GVE.

# üìç2.Coleta dos Dados

## ‚öôÔ∏è2.1 Extra√ß√£o dos Dados e Tratamento
Instala√ß√£o e Importa√ß√£o das Bibliotecas
"""

!pip install pandas
!pip install geopandas
!pip install numpy
!pip install seaborn
!pip install matplotlib
!pip install scikit-learn
!pip install beautifulsoup4
!pip install yellowbrick
!pip install requests
!pip install geopandas geobr rtree
!pip install matplotlib
!pip install descartes
!pip install basemap
!pip install pmdarima
!pip install scikit-learn

# Commented out IPython magic to ensure Python compatibility.
import requests                 # Usado para fazer requisi√ß√µes HTTP a APIs ou p√°ginas da web.
from bs4 import BeautifulSoup   # Lib para extrair dados de arquivos HTML e XML.
import pandas as pd             # Lib para manipula√ß√£o e an√°lise de dados.
import geopandas as gpd         # Extens√£o de pandas para trabalhar com dados espaciais (geogr√°ficos).
import numpy as np              # Lib para suporte a arrays e matrizes multidimensionais e opera√ß√µes matem√°ticas.
import datetime                 # M√≥dulo para manipula√ß√£o de datas e hor√°rios.
from datetime import datetime, timedelta   # Importa√ß√µes espec√≠ficas de datetime para manipula√ß√£o de datas e hor√°rios.
import seaborn as sns           # Lib de visualiza√ß√£o de dados baseada em matplotlib, para gr√°ficos estat√≠sticos mais bonitos.
import matplotlib.pyplot as plt # M√≥dulo de matplotlib para cria√ß√£o de gr√°ficos e visualiza√ß√µes de dados.
from scipy import optimize      # Lib para otimiza√ß√£o matem√°tica, incluindo resolu√ß√£o de equa√ß√µes e minimiza√ß√£o de fun√ß√µes.
from io import BytesIO          # M√≥dulo para tratar fluxos de bytes em mem√≥ria como um arquivo.
from zipfile import ZipFile     # M√≥dulo para ler e escrever arquivos ZIP.

# Necess√°rio para visualiza√ß√£o autom√°tica dos gr√°ficos no Jupyter.
# %matplotlib inline

from pathlib import Path                    # M√≥dulo para manipula√ß√£o de caminhos de sistema de arquivos de forma orientada a objetos.
from pandas import json_normalize           # Fun√ß√£o para normalizar dados semi-estruturados JSON em um dataframe plano.

# sklearn √© uma lib de aprendizado de m√°quina.
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix, roc_auc_score, roc_curve, silhouette_score # M√©tricas para avaliar modelos de classifica√ß√£o.
from sklearn.model_selection import train_test_split       # Fun√ß√£o para dividir arrays ou matrizes em subconjuntos aleat√≥rios de treino e teste.
from sklearn.neighbors import KNeighborsClassifier         # Implementa√ß√£o do classificador k-vizinhos mais pr√≥ximos.
from sklearn import preprocessing                          # M√≥dulo para pr√©-processamento de dados.
from sklearn.model_selection import GridSearchCV           # Ferramenta para busca de hiperpar√¢metros.
from sklearn.ensemble import RandomForestClassifier        # Implementa√ß√£o do classificador de florestas aleat√≥rias.
from sklearn.preprocessing import StandardScaler           # Utilizado para normalizar os dados, ajustando-os para terem m√©dia 0 e vari√¢ncia 1.
from sklearn.decomposition import PCA                      # PCA (Principal Component Analysis) √© usado para reduzir a dimensionalidade dos dados mantendo a maior parte da informa√ß√£o.
from yellowbrick.classifier import ClassificationReport    # Ferramenta de visualiza√ß√£o para relat√≥rios de classifica√ß√£o de modelos.
import geobr                                               # Lib para acessar dados geogr√°ficos do Brasil.
import rtree                                               # Lib para indexa√ß√£o espacial r√°pida.
from geobr import read_municipality                        # Fun√ß√£o para ler dados geogr√°ficos dos munic√≠pios brasileiros.
import folium                                              # Lib para cria√ß√£o de mapas interativos.
from folium import plugins                                 # Plugins para a lib folium.
from folium.plugins import MarkerCluster, HeatMap          # Plugins para agrupamento de marcadores e mapas de calor.
from folium import Choropleth, Circle, CircleMarker, PolyLine, Polygon, GeoJson, FeatureGroup, LayerControl # Componentes para adicionar ao mapa folium.
from sklearn.cluster import KMeans                         # Implementa√ß√£o do algoritmo K-Means para clustering.
import locale                                              # M√≥dulo para configura√ß√£o regional do sistema operacional. Utilizado para formata√ß√£o de n√∫meros, datas e strings.
from mpl_toolkits.basemap import Basemap                   # M√≥dulo do matplotlib para cria√ß√£o de mapas base e visualiza√ß√£o geogr√°fica.
import pmdarima as pm                                      # Lib para modelagem ARIMA automatizada e sele√ß√£o de modelos.
import warnings                                            # M√≥dulo para controle de avisos e mensagens de alerta.
warnings.simplefilter("ignore")                            # Configura√ß√£o para ignorar avisos n√£o cr√≠ticos.
from prophet import Prophet                                # Lib para previs√£o de s√©ries temporais baseada em modelos aditivos.
from sklearn.linear_model import LinearRegression          # Implementa√ß√£o do modelo de regress√£o linear.
from prophet.plot import add_changepoints_to_plot          # Fun√ß√£o para adicionar pontos de mudan√ßa a gr√°ficos do Prophet.
import matplotlib.dates as mdates                          # M√≥dulo para manipula√ß√£o de datas em gr√°ficos matplotlib.

"""Iniciando Extra√ß√£o dos dados

### ‚úÖFONTE_1 : CASOS-OBITOS POR MUNICIPIO E DATA
SEADE - https://repositorio.seade.gov.br
"""

# URL do arquivo ZIP da FONTE_1
url1 = "https://repositorio.seade.gov.br/dataset/b4bd5b75-0c6c-44d9-8fc4-9c5d9a480647/resource/d2bad7a1-6c38-4dda-b409-656bff3fa56a/download/dados_covid_sp.zip"

# Fazendo o download do arquivo ZIP com a verifica√ß√£o de SSL desativada
response = requests.get(url1, verify=False)

# Verifica se a requisi√ß√£o foi bem sucedida:
if response.status_code == 200:
    zipfile = ZipFile(BytesIO(response.content))
    # Extrai o nome do arquivo CSV dentro do ZIP
    csv_filename = zipfile.namelist()[0]
    # L√™ o arquivo CSV dentro do ZIP e carrega em um DataFrame, usando o delimitador ponto e v√≠rgula
    df_font1 = pd.read_csv(zipfile.open(csv_filename), sep=';')

    print("\n\n‚úÖCSV da FONTE_1:'" + csv_filename + "' carregado em um DataFrame com sucesso!\n\nüîéFonte atualizada e consultada dia 19 de novembro de 2023, 09:56 (UTC-03:00)")
else:
    print("‚ùåFalha no download do arquivo. Status code:", response.status_code)

"""#### Tratamento dos dados da FONTE_1


"""

# Convertendo os t√≠tulos das colunas para mai√∫sculas
df_font1.columns = [col.upper() for col in df_font1.columns]

df_font1.info()

# Convertendo todo o conte√∫do da coluna 'NOME_MUNIC' e 'NOME_DRS' para mai√∫sculas
df_font1['NOME_MUNIC'] = df_font1['NOME_MUNIC'].str.upper()
#df_font1['NOME_DRS'] = df_font1['NOME_DRS'].str.upper()

display(df_font1.head())

# Encontrando a data m√°xima na coluna 'DATAHORA'
data_max = df_font1['DATAHORA'].max()
data_min = df_font1['DATAHORA'].min()

# Exibindo o intervalo da fonte de dados
print(f"A FONTE_1 possui dados entre {data_min} e {data_max}")

# Sabendo o Intervalos, vamos calcular quantos dias temos de dados em toda pandemia at√© dia 01/11/2023
start_date = datetime(2020, 2, 25)
end_date   = datetime(2023, 11, 1)

# Calcula a diferen√ßa entre as datas
delta = end_date - start_date

# Retorna o n√∫mero de dias
print(f"{delta.days} dias")

num_linhas1 = df_font1.shape[0]
num_linhas1_formatado = "{:,}".format(num_linhas1).replace(",", ".")
print(f"O n√∫mero de linhas na FONTE_1 √©: {num_linhas1_formatado}")

# Validando a fonte com dados publicados na imprensa:

# 1- Garantir que a coluna 'DATAHORA' est√° no formato de data
df_font1['DATAHORA'] = pd.to_datetime(df_font1['DATAHORA'])

# 2- Extrair o ano da coluna 'DATAHORA'
df_font1['ANO'] = df_font1['DATAHORA'].dt.year

# 3 - Agrupar a FONTE_1 pelo ANO e calcular a soma das colunas 'CASOS_NOVOS' e 'OBITOS_NOVOS'
agrupado_por_ano = df_font1.groupby('ANO')[['CASOS_NOVOS', 'OBITOS_NOVOS']].sum()

# 4 Fun√ß√£o para formatar os n√∫meros com pontos como separadores de milhar
def formatar_com_pontos(numero):
    return "{:,}".format(numero).replace(",", ".")

# 5 Aplicando a formata√ß√£o aos dados agrupados
agrupado_por_ano_formatado = agrupado_por_ano.applymap(formatar_com_pontos)

# 6 - Apenas somar as colunas 'CASOS_NOVOS' e 'OBITOS_NOVOS'
casos_obitos_total = df_font1[['CASOS_NOVOS', 'OBITOS_NOVOS']].sum()

# 7 Formatando o total de casos e √≥bitos
casos_obitos_total_formatado = casos_obitos_total.apply(formatar_com_pontos)

# 9 Exibindo o resultado
print("\n\n" + agrupado_por_ano_formatado.to_string(index=False) + "\n\n")
print("\n\n" + casos_obitos_total_formatado.to_string(index=False) + "\n\n")

"""Fonte 1, confere com os dados publicados no Boletim Epidemiol√≥gico consultado no dia 19/11/2023: http://saude.sp.gov.br/resources/cve-centro-de-vigilancia-epidemiologica/areas-de-vigilancia/doencas-de-transmissao-respiratoria/coronavirus/2023/novembro/covid181123.pdf

Importante: Os dados rodados pelo script, podem ser um pouco maiores ap√≥s essa data, tendo em vista que as unidades realizam lan√ßamentos retroativos, portanto, tanto o n√∫mero de casos quanto de √≥bitos pode variar sempre para mais.

Mas em 19/11/2023 os dados an√°lisados s√£o da imagem abaixo:

![image.png](data:image/png;base64,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)
"""

# Exibindo as primeiras linhas do DataFrame resultante para verificar
display(df_font1.head())

#Definindo o Sistema de proje√ß√£o
df_font1.crs = 'EPSG:4326'
df_font1.crs

df_font1.info()

"""### ‚úÖFONTE_2 : CASOS-OBITOS POR MUNICIPIO E RACA/COR
SEADE - https://repositorio.seade.gov.br
"""

# URL do arquivo ZIP da FONTE_2
url2 = "https://repositorio.seade.gov.br/dataset/b4bd5b75-0c6c-44d9-8fc4-9c5d9a480647/resource/a730d5c1-7899-4455-8649-68e7e8cc1753/download/casos_obitos_raca_cor.csv.zip"

# Fazendo o download do arquivo ZIP com a verifica√ß√£o de SSL desativada
response2 = requests.get(url2, verify=False)

# Verifica se a requisi√ß√£o foi bem sucedida:
if response2.status_code == 200:
    zipfile2 = ZipFile(BytesIO(response2.content))
    # Extrai o nome do arquivo CSV dentro do ZIP
    csv_filename2 = zipfile2.namelist()[0]
    # L√™ o arquivo CSV dentro do ZIP e carrega em um DataFrame, usando o delimitador ponto e v√≠rgula
    df_font2 = pd.read_csv(zipfile2.open(csv_filename2), sep=';')

    print("\n\n‚úÖCSV da FONTE_2:'" + csv_filename2 + "' carregado em um DataFrame com sucesso!\n\nüîéFonte atualizada e consultada dia 19 de novembro de 2023, 09:56 (UTC-03:00)")
else:
    print("‚ùåFalha no download do arquivo. Status code:", response.status_code)

"""#### Tratamento dos dados da FONTE_2


"""

# Convertendo os t√≠tulos das colunas para mai√∫sculas
df_font2.columns = [col.upper() for col in df_font2.columns]

# Convertendo todo o conte√∫do da coluna 'NOME_MUNIC' e 'NOME_DRS' para mai√∫sculas
df_font2['NOME_MUNIC'] = df_font2['NOME_MUNIC'].str.upper()
df_font2['NOME_DRS'] = df_font2['NOME_DRS'].str.upper()

# Convertendo as colunas para string e removendo o ponto e os caracteres ap√≥s ele
df_font2['CODIGO_IBGE'] = df_font2['CODIGO_IBGE'].astype(str).str.split('.').str[0]
df_font2['IDADE']       = df_font2['IDADE'].astype(str).str.split('.').str[0]

df_font2.info()

# Exibindo as primeiras linhas do DataFrame resultante para verificar
display(df_font2.head())

num_linhas2 = df_font2.shape[0]
num_linhas2_formatado = "{:,}".format(num_linhas2).replace(",", ".")
print(f"O n√∫mero de linhas na FONTE_2 √©: {num_linhas2_formatado}")

#Definindo o Sistema de proje√ß√£o
df_font2.crs = 'EPSG:4326'
df_font2.crs

df_font2.info()

"""### ‚úÖFONTE_3 : GVE & DRS
DRS: https://www.saude.sp.gov.br/ses/institucional/departamentos-regionais-de-saude/regionais-de-saude

"""

# Criar DataFrame com a rela√ß√£o de GVE e DRS que n√£o est√° publica, √© uma informa√ß√£o interna da SES-SP para enriquecimento dos datasets
dataGVE_DRS = {
      'COD_MUNICIPIO':['350390','350570','350660','350900','350920','351060','351300','351380','351500','351510','351570','351630','351640','351830','351880','352220','352250','352310','352500','352620','352850','352940','353060','353440','353910','353980','354330','354410','354500','354680','354730','354780','354870','354880','354995','355030','355250','355280','355645','350110','350210','350280','350420','350440','350510','350620','350640','350650','350770','350775','350810','351100','351190','351250','351650','351710','351780','351820','351890','352044','352300','352650','352725','352770','353010','353210','353286','353320','353330','353730','353740','353770','354440','354805','354840','355230','355255','355520','355630','350170','350320','350670','350740','351010','351370','351400','351430','351685','351930','351960','352270','352930','353205','353290','354070','354290','354370','354650','354690','354890','355270','355370','355475','350635','351350','351870','352210','353110','353760','354100','354850','355100','350090','350550','350610','350930','351200','351210','351740','351790','352420','353150','353390','355190','355310','355320','355365','355440','355680','355690','350055','350070','350230','350310','350340','350360','350430','350450','350470','350500','350520','350530','350600','350680','350690','350730','350745','350750','350790','350830','350880','351140','351230','351260','351410','351450','351540','351700','351720','351910','351925','352000','352180','352200','352280','352290','352350','352530','352640','352680','352710','352750','352800','352860','352980','353580','353610','353657','353670','353750','353880','353890','353940','354010','354050','354105','354110','354160','354250','354460','355010','355120','355300','355380','355420','355465','355470','355590','350050','350160','350190','350380','350410','350710','350760','350840','350950','350960','351280','351905','351907','352050','352340','352400','352470','352520','352550','352590','352700','352730','353120','353180','353200','353240','353340','353650','353680','353710','353820','353860','354580','354800','355160','355210','355240','355495','355620','355635','355650','355670','350300','350820','351320','351620','351770','352010','352130','352370','352410','352540','352970','353190','353360','353430','353630','353700','354270','354310','354360','354490','354940','354950','350010','350140','350150','350335','350400','350580','350630','350720','350980','351000','351015','355720','351330','351470','351519','351565','351600','351610','351660','351670','351730','351810','351900','351920','351950','352080','352090','352580','352740','352780','352790','352880','352890','352900','353370','353380','353410','353450','353460','353470','353490','353530','353550','353600','353715','353970','354000','354085','354180','354200','354320','354380','354470','354510','354540','354640','355050','355395','355460','355500','355550','355660','350060','350200','350330','351040','351170','351220','351240','351270','351490','351515','352110','352140','352360','352670','352690','353090','353870','353930','354210','354390','354400','354515','354620','354670','354700','355040','350080','350130','350240','350890','350910','351440','351512','351530','351535','351580','351990','352060','352160','352560','352600','352870','352920','353020','353160','353215','353220','353310','353480','353540','353640','353830','353920','354120','354130','354140','354150','354170','354220','354240','354323','354425','354550','354710','354770','354830','354930','355290','355390','355430','355510','350540','350925','350990','351480','352030','352042','352120','352330','352460','352610','352990','353620','353720','354260','355180','350100','350560','350590','350780','350940','351090','351310','351460','351860','351885','352430','352510','352760','353130','353950','354020','354090','354340','354625','354750','354760','354790','355090','355140','355150','355170','350030','350040','350870','351080','351390','351518','355730','352260','352380','353050','353070','353080','354630','354810','354910','354970','355080','355330','355360','355640','350020','350120','350180','350260','350370','350395','350460','350480','351070','351110','351120','351130','351290','351385','351420','351492','351495','351520','351560','351550','351590','351680','351690','351750','351800','351940','351980','352070','352115','352150','352190','352450','352480','352570','352810','352820','352830','352885','352910','352950','352960','352965','353000','353030','353040','353100','353140','353250','353260','353270','353280','353284','353300','353325','353350','353400','353420','353475','353500','353510','353520','353570','353590','353625','353660','353690','353810','353900','353960','353990','354025','354030','354040','354080','354420','354450','354480','354560','354570','354610','354660','354740','354765','354720','354900','354920','354925','354980','355130','355260','355340','355490','355530','355535','355560','355570','355580','355600','355610','355695','355710','355715','350075','350115','350220','350270','350275','350290','350535','350700','350715','350800','350945','351020','351030','351150','351160','351760','351850','351970','352100','352170','352215','352230','352240','352265','352320','352390','352585','352840','353282','353780','353790','354060','354165','354280','354300','354325','354350','354520','354530','355020','355060','355110','355220','355350','355385','355400','355450','355700','350250','350315','350350','350490','350850','350860','350970','350995','351050','351340','351360','351840','352020','352040','352440','352490','352630','352660','352720','353170','353230','353560','353800','353850','354075','354190','354230','354430','354600','354820','354860','354960','354990','355000','355070','355200','355410','355480','355540'],
      'COD_MUNICIPIO_7':['3503901','3505708','3506607','3509007','3509205','3510609','3513009','3513801','3515004','3515103','3515707','3516309','3516408','3518305','3518800','3522208','3522505','3523107','3525003','3526209','3528502','3529401','3530607','3534401','3539103','3539806','3543303','3544103','3545001','3546801','3547304','3547809','3548708','3548807','3549953','3550308','3552502','3552809','3556453','3501103','3502101','3502804','3504206','3504404','3505104','3506201','3506409','3506508','3507704','3507753','3508108','3511003','3511904','3512506','3516507','3517109','3517802','3518206','3518909','3520442','3523008','3526506','3527256','3527702','3530102','3532108','3532868','3533205','3533304','3537305','3537404','3537701','3544400','3548054','3548401','3552304','3552551','3555208','3556305','3501707','3503208','3506706','3507407','3510104','3513702','3514007','3514304','3516853','3519303','3519600','3522703','3529302','3532058','3532900','3540705','3542909','3543709','3546504','3546900','3548906','3552700','3553708','3554755','3506359','3513504','3518701','3522109','3531100','3537602','3541000','3548500','3551009','3500907','3505500','3506102','3509304','3512001','3512100','3517406','3517901','3524204','3531506','3533908','3551900','3553104','3553203','3553658','3554409','3556800','3556909','3500550','3500709','3502309','3503109','3503406','3503604','3504305','3504503','3504701','3505005','3505203','3505302','3506003','3506805','3506904','3507308','3507456','3507506','3507902','3508306','3508801','3511409','3512308','3512605','3514106','3514502','3515400','3517000','3517208','3519105','3519253','3520004','3521804','3522000','3522802','3522901','3523503','3525300','3526407','3526803','3527108','3527504','3528007','3528601','3529807','3535804','3536109','3536570','3536703','3537503','3538808','3538907','3539400','3540101','3540507','3541059','3541109','3541604','3542503','3544608','3550100','3551207','3553005','3553807','3554201','3554656','3554706','3555901','3500501','3501608','3501905','3503802','3504107','3507100','3507605','3508405','3509502','3509601','3512803','3519055','3519071','3520509','3523404','3524006','3524709','3525201','3525508','3525904','3527009','3527306','3531209','3531803','3532009','3532405','3533403','3536505','3536802','3537107','3538204','3538600','3545803','3548005','3551603','3552106','3552403','3554953','3556206','3556354','3556503','3556701','3503000','3508207','3513207','3516200','3517703','3520103','3521309','3523701','3524105','3525409','3529708','3531902','3533601','3534302','3536307','3537008','3542701','3543105','3543600','3544905','3549409','3549508','3500105','3501400','3501509','3503356','3504008','3505807','3506300','3507209','3509809','3510005','3510153','3557204','3513306','3514700','3515194','3515657','3516002','3516101','3516606','3516705','3517307','3518107','3519006','3519204','3519501','3520806','3520905','3525805','3527405','3527801','3527900','3528809','3528908','3529005','3533700','3533809','3534104','3534500','3534609','3534708','3534906','3535309','3535507','3536000','3537156','3539707','3540002','3540853','3541802','3542008','3543204','3543808','3544707','3545100','3545407','3546405','3550506','3553955','3554607','3555000','3555505','3556602','3500600','3502002','3503307','3510401','3511706','3512209','3512407','3512704','3514908','3515152','3521101','3521408','3523602','3526704','3526902','3530904','3538709','3539301','3542107','3543907','3544004','3545159','3546207','3546702','3547007','3550407','3500808','3501301','3502408','3508900','3509106','3514403','3515129','3515301','3515350','3515806','3519907','3520608','3521606','3525607','3526001','3528700','3529203','3530201','3531605','3532157','3532207','3533106','3534807','3535408','3536406','3538303','3539202','3541208','3541307','3541406','3541505','3541703','3542206','3542404','3543238','3544251','3545506','3547106','3547700','3548302','3549300','3552908','3553906','3554300','3555109','3505401','3509254','3509908','3514809','3520301','3520426','3521200','3523305','3524600','3526100','3529906','3536208','3537206','3542602','3551801','3501004','3505609','3505906','3507803','3509403','3510906','3513108','3514601','3518602','3518859','3524303','3525102','3527603','3531308','3539509','3540200','3540903','3543402','3546256','3547502','3547601','3547908','3550902','3551405','3551504','3551702','3500303','3500402','3508702','3510807','3513900','3515186','3557303','3522604','3523800','3530508','3530706','3530805','3546306','3548104','3549102','3549706','3550803','3553302','3553609','3556404','3500204','3501202','3501806','3502606','3503703','3503950','3504602','3504800','3510708','3511102','3511201','3511300','3512902','3513850','3514205','3514924','3514957','3515202','3515608','3515509','3515905','3516804','3516903','3517505','3518008','3519402','3519808','3520707','3521150','3521507','3521903','3524501','3524808','3525706','3528106','3528205','3528304','3528858','3529104','3529500','3529609','3529658','3530003','3530300','3530409','3531001','3531407','3532504','3532603','3532702','3532801','3532843','3533007','3533254','3533502','3534005','3534203','3534757','3535002','3535101','3535200','3535705','3535903','3536257','3536604','3536901','3538105','3539004','3539608','3539905','3540259','3540309','3540408','3540804','3544202','3544509','3544806','3545605','3545704','3546108','3546603','3547403','3547650','3547205','3549003','3549201','3549250','3549805','3551306','3552601','3553401','3554904','3555307','3555356','3555604','3555703','3555802','3556008','3556107','3556958','3557105','3557154','3500758','3501152','3502200','3502705','3502754','3502903','3505351','3507001','3507159','3508009','3509452','3510203','3510302','3511508','3511607','3517604','3518503','3519709','3521002','3521705','3522158','3522307','3522406','3522653','3523206','3523909','3525854','3528403','3532827','3537800','3537909','3540606','3541653','3542800','3543006','3543253','3543501','3545209','3545308','3550209','3550605','3551108','3552205','3553500','3553856','3554003','3554508','3557006','3502507','3503158','3503505','3504909','3508504','3508603','3509700','3509957','3510500','3513405','3513603','3518404','3520202','3520400','3524402','3524907','3526308','3526605','3527207','3531704','3532306','3535606','3538006','3538501','3540754','3541901','3542305','3544301','3546009','3548203','3548609','3549607','3549904','3550001','3550704','3552007','3554102','3554805','3555406'],
      'MUNICIPIO':['ARUJA','BARUERI','BIRITIBA-MIRIM','CAIEIRAS','CAJAMAR','CARAPICUIBA','COTIA','DIADEMA','EMBU DAS ARTES','EMBU-GUACU','FERRAZ DE VASCONCELOS','FRANCISCO MORATO','FRANCO DA ROCHA','GUARAREMA','GUARULHOS','ITAPECERICA DA SERRA','ITAPEVI','ITAQUAQUECETUBA','JANDIRA','JUQUITIBA','MAIRIPORA','MAUA','MOGI DAS CRUZES','OSASCO','PIRAPORA DO BOM JESUS','POA','RIBEIRAO PIRES','RIO GRANDE DA SERRA','SALESOPOLIS','SANTA ISABEL','SANTANA DE PARNAIBA','SANTO ANDRE','SAO BERNARDO DO CAMPO','SAO CAETANO DO SUL','SAO LOURENCO DA SERRA','SAO PAULO','SUZANO','TABOAO DA SERRA','VARGEM GRANDE PAULISTA','ALTO ALEGRE','ANDRADINA','ARACATUBA','AURIFLAMA','AVANHANDAVA','BARBOSA','BENTO DE ABREU','BILAC','BIRIGUI','BRAUNA','BREJO ALEGRE','BURITAMA','CASTILHO','CLEMENTINA','COROADOS','GABRIEL MONTEIRO','GLICERIO','GUARACAI','GUARARAPES','GUZOLANDIA','ILHA SOLTEIRA','ITAPURA','LAVINIA','LOURDES','LUIZIANIA','MIRANDOPOLIS','MURUTINGA DO SUL','NOVA CASTILHO','NOVA INDEPENDENCIA','NOVA LUZITANIA','PENAPOLIS','PEREIRA BARRETO','PIACATU','RUBIACEA','SANTO ANTONIO DO ARACANGUA','SANTOPOLIS DO AGUAPEI','SUD MENNUCCI','SUZANAPOLIS','TURIUBA','VALPARAISO','AMERICO BRASILIENSE','ARARAQUARA','BOA ESPERANCA DO SUL','BORBOREMA','CANDIDO RODRIGUES','DESCALVADO','DOBRADA','DOURADO','GAVIAO PEIXOTO','IBATE','IBITINGA','ITAPOLIS','MATAO','MOTUCA','NOVA EUROPA','PORTO FERREIRA','RIBEIRAO BONITO','RINCAO','SANTA ERNESTINA','SANTA LUCIA','SAO CARLOS','TABATINGA','TAQUARITINGA','TRABIJU','BERTIOGA','CUBATAO','GUARUJA','ITANHAEM','MONGAGUA','PERUIBE','PRAIA GRANDE','SANTOS','SAO VICENTE','ALTAIR','BARRETOS','BEBEDOURO','CAJOBI','COLINA','COLOMBIA','GUAIRA','GUARACI','JABORANDI','MONTE AZUL PAULISTA','OLIMPIA','SEVERINIA','TAIACU','TAIUVA','TAQUARAL','TERRA ROXA','VIRADOURO','VISTA ALEGRE DO ALTO','AGUAS DE SANTA BARBARA','AGUDOS','ANHEMBI','ARANDU','AREALVA','AREIOPOLIS','AVAI','AVARE','BALBINOS','BARAO DE ANTONINA','BARIRI','BARRA BONITA','BAURU','BOCAINA','BOFETE','BORACEIA','BOREBI','BOTUCATU','BROTAS','CABRALIA PAULISTA','CAFELANDIA','CERQUEIRA CESAR','CONCHAS','CORONEL MACEDO','DOIS CORREGOS','DUARTINA','FARTURA','GETULINA','GUAICARA','IACANGA','IARAS','IGARACU DO TIETE','ITAI','ITAJU','ITAPORANGA','ITAPUI','ITATINGA','JAU','LARANJAL PAULISTA','LENCOIS PAULISTA','LINS','LUCIANOPOLIS','MACATUBA','MANDURI','MINEIROS DO TIETE','PARANAPANEMA','PARDINHO','PAULISTANIA','PEDERNEIRAS','PEREIRAS','PIRAJU','PIRAJUI','PIRATININGA','PONGAI','PORANGABA','PRATANIA','PRESIDENTE ALVES','PROMISSAO','REGINOPOLIS','SABINO','SAO MANUEL','SARUTAIA','TAGUAI','TAQUARITUBA','TEJUPA','TORRE DE PEDRA','TORRINHA','URU','AGUAS DE LINDOIA','AMERICANA','AMPARO','ARTUR NOGUEIRA','ATIBAIA','BOM JESUS DOS PERDOES','BRAGANCA PAULISTA','CABREUVA','CAMPINAS','CAMPO LIMPO PAULISTA','COSMOPOLIS','HOLAMBRA','HORTOLANDIA','INDAIATUBA','ITATIBA','ITUPEVA','JAGUARIUNA','JARINU','JOANOPOLIS','JUNDIAI','LINDOIA','LOUVEIRA','MONTE ALEGRE DO SUL','MONTE MOR','MORUNGABA','NAZARE PAULISTA','NOVA ODESSA','PAULINIA','PEDRA BELA','PEDREIRA','PINHALZINHO','PIRACAIA','SANTA BARBARA DOESTE','SANTO ANTONIO DE POSSE','SERRA NEGRA','SOCORRO','SUMARE','TUIUTI','VALINHOS','VARGEM','VARZEA PAULISTA','VINHEDO','ARAMINA','BURITIZAL','CRISTAIS PAULISTA','FRANCA','GUARA','IGARAPAVA','IPUA','ITIRAPUA','ITUVERAVA','JERIQUARA','MIGUELOPOLIS','MORRO AGUDO','NUPORANGA','ORLANDIA','PATROCINIO PAULISTA','PEDREGULHO','RESTINGA','RIBEIRAO CORRENTE','RIFAINA','SALES OLIVEIRA','SAO JOAQUIM DA BARRA','SAO JOSE DA BELA VISTA','ADAMANTINA','ALVARO DE CARVALHO','ALVINLANDIA','ARCO-IRIS','ASSIS','BASTOS','BERNARDINO DE CAMPOS','BORA','CAMPOS NOVOS PAULISTA','CANDIDO MOTA','CANITAR','CHAVANTES','CRUZALIA','ECHAPORA','ESPIRITO SANTO DO TURVO','FERNAO','FLORIDA PAULISTA','FLORINIA','GALIA','GARCA','GUAIMBE','GUARANTA','HERCULANDIA','IACRI','IBIRAREMA','INUBIA PAULISTA','IPAUSSU','JULIO MESQUITA','LUCELIA','LUPERCIO','LUTECIA','MARACAI','MARIAPOLIS','MARILIA','OCAUCU','OLEO','ORIENTE','OSCAR BRESSANE','OSVALDO CRUZ','OURINHOS','PACAEMBU','PALMITAL','PARAGUACU PAULISTA','PARAPUA','PEDRINHAS PAULISTA','PLATINA','POMPEIA','PRACINHA','QUEIROZ','QUINTANA','RIBEIRAO DO SUL','RINOPOLIS','SAGRES','SALMOURAO','SALTO GRANDE','SANTA CRUZ DO RIO PARDO','SAO PEDRO DO TURVO','TARUMA','TIMBURI','TUPA','UBIRAJARA','VERA CRUZ','AGUAS DE SAO PEDRO','ANALANDIA','ARARAS','CAPIVARI','CHARQUEADA','CONCHAL','CORDEIROPOLIS','CORUMBATAI','ELIAS FAUSTO','ENGENHEIRO COELHO','IPEUNA','IRACEMAPOLIS','ITIRAPINA','LEME','LIMEIRA','MOMBUCA','PIRACICABA','PIRASSUNUNGA','RAFARD','RIO CLARO','RIO DAS PEDRAS','SALTINHO','SANTA CRUZ DA CONCEICAO','SANTA GERTRUDES','SANTA MARIA DA SERRA','SAO PEDRO','ALFREDO MARCONDES','ALVARES MACHADO','ANHUMAS','CAIABU','CAIUA','DRACENA','EMILIANOPOLIS','ESTRELA DO NORTE','EUCLIDES DA CUNHA PAULISTA','FLORA RICA','IEPE','INDIANA','IRAPURU','JOAO RAMALHO','JUNQUEIROPOLIS','MARABA PAULISTA','MARTINOPOLIS','MIRANTE DO PARANAPANEMA','MONTE CASTELO','NANTES','NARANDIBA','NOVA GUATAPORANGA','OURO VERDE','PANORAMA','PAULICEIA','PIQUEROBI','PIRAPOZINHO','PRESIDENTE BERNARDES','PRESIDENTE EPITACIO','PRESIDENTE PRUDENTE','PRESIDENTE VENCESLAU','QUATA','RANCHARIA','REGENTE FEIJO','RIBEIRAO DOS INDIOS','ROSANA','SANDOVALINA','SANTA MERCEDES','SANTO ANASTACIO','SANTO EXPEDITO','SAO JOAO DO PAU DALHO','TACIBA','TARABAI','TEODORO SAMPAIO','TUPI PAULISTA','BARRA DO TURVO','CAJATI','CANANEIA','ELDORADO','IGUAPE','ILHA COMPRIDA','IPORANGA','ITARIRI','JACUPIRANGA','JUQUIA','MIRACATU','PARIQUERA-ACU','PEDRO DE TOLEDO','REGISTRO','SETE BARRAS','ALTINOPOLIS','BARRINHA','BATATAIS','BRODOWSKI','CAJURU','CASSIA DOS COQUEIROS','CRAVINHOS','DUMONT','GUARIBA','GUATAPARA','JABOTICABAL','JARDINOPOLIS','LUIS ANTONIO','MONTE ALTO','PITANGUEIRAS','PONTAL','PRADOPOLIS','RIBEIRAO PRETO','SANTA CRUZ DA ESPERANCA','SANTA RITA DO PASSA QUATRO','SANTA ROSA DE VITERBO','SANTO ANTONIO DA ALEGRIA','SAO SIMAO','SERRA AZUL','SERRANA','SERTAOZINHO','AGUAI','AGUAS DA PRATA','CACONDE','CASA BRANCA','DIVINOLANDIA','ESPIRITO SANTO DO PINHAL','ESTIVA GERBI','ITAPIRA','ITOBI','MOCOCA','MOGI GUACU','MOGI MIRIM','SANTA CRUZ DAS PALMEIRAS','SANTO ANTONIO DO JARDIM','SAO JOAO DA BOA VISTA','SAO JOSE DO RIO PARDO','SAO SEBASTIAO DA GRAMA','TAMBAU','TAPIRATIBA','VARGEM GRANDE DO SUL','ADOLFO','ALVARES FLORENCE','AMERICO DE CAMPOS','APARECIDA DOESTE','ARIRANHA','ASPASIA','BADY BASSITT','BALSAMO','CARDOSO','CATANDUVA','CATIGUA','CEDRAL','COSMORAMA','DIRCE REIS','DOLCINOPOLIS','ELISIARIO','EMBAUBA','ESTRELA DOESTE','FERNANDO PRESTES','FERNANDOPOLIS','FLOREAL','GASTAO VIDIGAL','GENERAL SALGADO','GUAPIACU','GUARANI DOESTE','IBIRA','ICEM','INDIAPORA','IPIGUA','IRAPUA','ITAJOBI','JACI','JALES','JOSE BONIFACIO','MACAUBAL','MACEDONIA','MAGDA','MARAPOAMA','MARINOPOLIS','MENDONCA','MERIDIANO','MESOPOLIS','MIRA ESTRELA','MIRASSOL','MIRASSOLANDIA','MONCOES','MONTE APRAZIVEL','NEVES PAULISTA','NHANDEARA','NIPOA','NOVA ALIANCA','NOVA CANAA PAULISTA','NOVA GRANADA','NOVAIS','NOVO HORIZONTE','ONDA VERDE','ORINDIUVA','OUROESTE','PALESTINA','PALMARES PAULISTA','PALMEIRA DOESTE','PARAISO','PARANAPUA','PARISI','PAULO DE FARIA','PEDRANOPOLIS','PINDORAMA','PIRANGI','PLANALTO','POLONI','PONTALINDA','PONTES GESTAL','POPULINA','POTIRENDABA','RIOLANDIA','RUBINEIA','SALES','SANTA ADELIA','SANTA ALBERTINA','SANTA CLARA DOESTE','SANTA FE DO SUL','SANTA RITA DOESTE','SANTA SALETE','SANTANA DA PONTE PENSA','SAO FRANCISCO','SAO JOAO DAS DUAS PONTES','SAO JOAO DE IRACEMA','SAO JOSE DO RIO PRETO','SEBASTIANOPOLIS DO SUL','TABAPUA','TANABI','TRES FRONTEIRAS','TURMALINA','UBARANA','UCHOA','UNIAO PAULISTA','URANIA','URUPES','VALENTIM GENTIL','VITORIA BRASIL','VOTUPORANGA','ZACARIAS','ALAMBARI','ALUMINIO','ANGATUBA','APIAI','ARACARIGUAMA','ARACOIABA DA SERRA','BARRA DO CHAPEU','BOITUVA','BOM SUCESSO DE ITARARE','BURI','CAMPINA DO MONTE ALEGRE','CAPAO BONITO','CAPELA DO ALTO','CERQUILHO','CESARIO LANGE','GUAPIARA','GUAREI','IBIUNA','IPERO','ITABERA','ITAOCA','ITAPETININGA','ITAPEVA','ITAPIRAPUA PAULISTA','ITARARE','ITU','JUMIRIM','MAIRINQUE','NOVA CAMPINA','PIEDADE','PILAR DO SUL','PORTO FELIZ','QUADRA','RIBEIRA','RIBEIRAO BRANCO','RIBEIRAO GRANDE','RIVERSUL','SALTO','SALTO DE PIRAPORA','SAO MIGUEL ARCANJO','SAO ROQUE','SARAPUI','SOROCABA','TAPIRAI','TAQUARIVAI','TATUI','TIETE','VOTORANTIM','APARECIDA','ARAPEI','AREIAS','BANANAL','CACAPAVA','CACHOEIRA PAULISTA','CAMPOS DO JORDAO','CANAS','CARAGUATATUBA','CRUZEIRO','CUNHA','GUARATINGUETA','IGARATA','ILHABELA','JACAREI','JAMBEIRO','LAGOINHA','LAVRINHAS','LORENA','MONTEIRO LOBATO','NATIVIDADE DA SERRA','PARAIBUNA','PINDAMONHANGABA','PIQUETE','POTIM','QUELUZ','REDENCAO DA SERRA','ROSEIRA','SANTA BRANCA','SANTO ANTONIO DO PINHAL','SAO BENTO DO SAPUCAI','SAO JOSE DO BARREIRO','SAO JOSE DOS CAMPOS','SAO LUIS DO PARAITINGA','SAO SEBASTIAO','SILVEIRAS','TAUBATE','TREMEMBE','UBATUBA'],
      'COD_17DRS':['1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','2','2','2','2','2','2','2','2','2','2','2','2','2','2','2','2','2','2','2','2','2','2','2','2','2','2','2','2','2','2','2','2','2','2','2','2','2','2','2','2','3','3','3','3','3','3','3','3','3','3','3','3','3','3','3','3','3','3','3','3','3','3','3','3','4','4','4','4','4','4','4','4','4','5','5','5','5','5','5','5','5','5','5','5','5','5','5','5','5','5','5','6','6','6','6','6','6','6','6','6','6','6','6','6','6','6','6','6','6','6','6','6','6','6','6','6','6','6','6','6','6','6','6','6','6','6','6','6','6','6','6','6','6','6','6','6','6','6','6','6','6','6','6','6','6','6','6','6','6','6','6','6','6','6','6','6','6','6','6','7','7','7','7','7','7','7','7','7','7','7','7','7','7','7','7','7','7','7','7','7','7','7','7','7','7','7','7','7','7','7','7','7','7','7','7','7','7','7','7','7','7','8','8','8','8','8','8','8','8','8','8','8','8','8','8','8','8','8','8','8','8','8','8','9','9','9','9','9','9','9','9','9','9','9','9','9','9','9','9','9','9','9','9','9','9','9','9','9','9','9','9','9','9','9','9','9','9','9','9','9','9','9','9','9','9','9','9','9','9','9','9','9','9','9','9','9','9','9','9','9','9','9','9','9','9','10','10','10','10','10','10','10','10','10','10','10','10','10','10','10','10','10','10','10','10','10','10','10','10','10','10','11','11','11','11','11','11','11','11','11','11','11','11','11','11','11','11','11','11','11','11','11','11','11','11','11','11','11','11','11','11','11','11','11','11','11','11','11','11','11','11','11','11','11','11','11','12','12','12','12','12','12','12','12','12','12','12','12','12','12','12','13','13','13','13','13','13','13','13','13','13','13','13','13','13','13','13','13','13','13','13','13','13','13','13','13','13','14','14','14','14','14','14','14','14','14','14','14','14','14','14','14','14','14','14','14','14','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','15','16','16','16','16','16','16','16','16','16','16','16','16','16','16','16','16','16','16','16','16','16','16','16','16','16','16','16','16','16','16','16','16','16','16','16','16','16','16','16','16','16','16','16','16','16','16','16','16','17','17','17','17','17','17','17','17','17','17','17','17','17','17','17','17','17','17','17','17','17','17','17','17','17','17','17','17','17','17','17','17','17','17','17','17','17','17','17'],
      'DRS_17':['GRANDE SAO PAULO','GRANDE SAO PAULO','GRANDE SAO PAULO','GRANDE SAO PAULO','GRANDE SAO PAULO','GRANDE SAO PAULO','GRANDE SAO PAULO','GRANDE SAO PAULO','GRANDE SAO PAULO','GRANDE SAO PAULO','GRANDE SAO PAULO','GRANDE SAO PAULO','GRANDE SAO PAULO','GRANDE SAO PAULO','GRANDE SAO PAULO','GRANDE SAO PAULO','GRANDE SAO PAULO','GRANDE SAO PAULO','GRANDE SAO PAULO','GRANDE SAO PAULO','GRANDE SAO PAULO','GRANDE SAO PAULO','GRANDE SAO PAULO','GRANDE SAO PAULO','GRANDE SAO PAULO','GRANDE SAO PAULO','GRANDE SAO PAULO','GRANDE SAO PAULO','GRANDE SAO PAULO','GRANDE SAO PAULO','GRANDE SAO PAULO','GRANDE SAO PAULO','GRANDE SAO PAULO','GRANDE SAO PAULO','GRANDE SAO PAULO','GRANDE SAO PAULO','GRANDE SAO PAULO','GRANDE SAO PAULO','GRANDE SAO PAULO','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARARAQUARA','ARARAQUARA','ARARAQUARA','ARARAQUARA','ARARAQUARA','ARARAQUARA','ARARAQUARA','ARARAQUARA','ARARAQUARA','ARARAQUARA','ARARAQUARA','ARARAQUARA','ARARAQUARA','ARARAQUARA','ARARAQUARA','ARARAQUARA','ARARAQUARA','ARARAQUARA','ARARAQUARA','ARARAQUARA','ARARAQUARA','ARARAQUARA','ARARAQUARA','ARARAQUARA','BAIXADA SANTISTA','BAIXADA SANTISTA','BAIXADA SANTISTA','BAIXADA SANTISTA','BAIXADA SANTISTA','BAIXADA SANTISTA','BAIXADA SANTISTA','BAIXADA SANTISTA','BAIXADA SANTISTA','BARRETOS','BARRETOS','BARRETOS','BARRETOS','BARRETOS','BARRETOS','BARRETOS','BARRETOS','BARRETOS','BARRETOS','BARRETOS','BARRETOS','BARRETOS','BARRETOS','BARRETOS','BARRETOS','BARRETOS','BARRETOS','BAURU','BAURU','BAURU','BAURU','BAURU','BAURU','BAURU','BAURU','BAURU','BAURU','BAURU','BAURU','BAURU','BAURU','BAURU','BAURU','BAURU','BAURU','BAURU','BAURU','BAURU','BAURU','BAURU','BAURU','BAURU','BAURU','BAURU','BAURU','BAURU','BAURU','BAURU','BAURU','BAURU','BAURU','BAURU','BAURU','BAURU','BAURU','BAURU','BAURU','BAURU','BAURU','BAURU','BAURU','BAURU','BAURU','BAURU','BAURU','BAURU','BAURU','BAURU','BAURU','BAURU','BAURU','BAURU','BAURU','BAURU','BAURU','BAURU','BAURU','BAURU','BAURU','BAURU','BAURU','BAURU','BAURU','BAURU','BAURU','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','FRANCA','FRANCA','FRANCA','FRANCA','FRANCA','FRANCA','FRANCA','FRANCA','FRANCA','FRANCA','FRANCA','FRANCA','FRANCA','FRANCA','FRANCA','FRANCA','FRANCA','FRANCA','FRANCA','FRANCA','FRANCA','FRANCA','MARILIA','MARILIA','MARILIA','MARILIA','MARILIA','MARILIA','MARILIA','MARILIA','MARILIA','MARILIA','MARILIA','MARILIA','MARILIA','MARILIA','MARILIA','MARILIA','MARILIA','MARILIA','MARILIA','MARILIA','MARILIA','MARILIA','MARILIA','MARILIA','MARILIA','MARILIA','MARILIA','MARILIA','MARILIA','MARILIA','MARILIA','MARILIA','MARILIA','MARILIA','MARILIA','MARILIA','MARILIA','MARILIA','MARILIA','MARILIA','MARILIA','MARILIA','MARILIA','MARILIA','MARILIA','MARILIA','MARILIA','MARILIA','MARILIA','MARILIA','MARILIA','MARILIA','MARILIA','MARILIA','MARILIA','MARILIA','MARILIA','MARILIA','MARILIA','MARILIA','MARILIA','MARILIA','PIRACICABA','PIRACICABA','PIRACICABA','PIRACICABA','PIRACICABA','PIRACICABA','PIRACICABA','PIRACICABA','PIRACICABA','PIRACICABA','PIRACICABA','PIRACICABA','PIRACICABA','PIRACICABA','PIRACICABA','PIRACICABA','PIRACICABA','PIRACICABA','PIRACICABA','PIRACICABA','PIRACICABA','PIRACICABA','PIRACICABA','PIRACICABA','PIRACICABA','PIRACICABA','PRESIDENTE PRUDENTE','PRESIDENTE PRUDENTE','PRESIDENTE PRUDENTE','PRESIDENTE PRUDENTE','PRESIDENTE PRUDENTE','PRESIDENTE PRUDENTE','PRESIDENTE PRUDENTE','PRESIDENTE PRUDENTE','PRESIDENTE PRUDENTE','PRESIDENTE PRUDENTE','PRESIDENTE PRUDENTE','PRESIDENTE PRUDENTE','PRESIDENTE PRUDENTE','PRESIDENTE PRUDENTE','PRESIDENTE PRUDENTE','PRESIDENTE PRUDENTE','PRESIDENTE PRUDENTE','PRESIDENTE PRUDENTE','PRESIDENTE PRUDENTE','PRESIDENTE PRUDENTE','PRESIDENTE PRUDENTE','PRESIDENTE PRUDENTE','PRESIDENTE PRUDENTE','PRESIDENTE PRUDENTE','PRESIDENTE PRUDENTE','PRESIDENTE PRUDENTE','PRESIDENTE PRUDENTE','PRESIDENTE PRUDENTE','PRESIDENTE PRUDENTE','PRESIDENTE PRUDENTE','PRESIDENTE PRUDENTE','PRESIDENTE PRUDENTE','PRESIDENTE PRUDENTE','PRESIDENTE PRUDENTE','PRESIDENTE PRUDENTE','PRESIDENTE PRUDENTE','PRESIDENTE PRUDENTE','PRESIDENTE PRUDENTE','PRESIDENTE PRUDENTE','PRESIDENTE PRUDENTE','PRESIDENTE PRUDENTE','PRESIDENTE PRUDENTE','PRESIDENTE PRUDENTE','PRESIDENTE PRUDENTE','PRESIDENTE PRUDENTE','REGISTRO','REGISTRO','REGISTRO','REGISTRO','REGISTRO','REGISTRO','REGISTRO','REGISTRO','REGISTRO','REGISTRO','REGISTRO','REGISTRO','REGISTRO','REGISTRO','REGISTRO','RIBEIRAO PRETO','RIBEIRAO PRETO','RIBEIRAO PRETO','RIBEIRAO PRETO','RIBEIRAO PRETO','RIBEIRAO PRETO','RIBEIRAO PRETO','RIBEIRAO PRETO','RIBEIRAO PRETO','RIBEIRAO PRETO','RIBEIRAO PRETO','RIBEIRAO PRETO','RIBEIRAO PRETO','RIBEIRAO PRETO','RIBEIRAO PRETO','RIBEIRAO PRETO','RIBEIRAO PRETO','RIBEIRAO PRETO','RIBEIRAO PRETO','RIBEIRAO PRETO','RIBEIRAO PRETO','RIBEIRAO PRETO','RIBEIRAO PRETO','RIBEIRAO PRETO','RIBEIRAO PRETO','RIBEIRAO PRETO','SAO JOAO DA BOA VISTA','SAO JOAO DA BOA VISTA','SAO JOAO DA BOA VISTA','SAO JOAO DA BOA VISTA','SAO JOAO DA BOA VISTA','SAO JOAO DA BOA VISTA','SAO JOAO DA BOA VISTA','SAO JOAO DA BOA VISTA','SAO JOAO DA BOA VISTA','SAO JOAO DA BOA VISTA','SAO JOAO DA BOA VISTA','SAO JOAO DA BOA VISTA','SAO JOAO DA BOA VISTA','SAO JOAO DA BOA VISTA','SAO JOAO DA BOA VISTA','SAO JOAO DA BOA VISTA','SAO JOAO DA BOA VISTA','SAO JOAO DA BOA VISTA','SAO JOAO DA BOA VISTA','SAO JOAO DA BOA VISTA','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SOROCABA','SOROCABA','SOROCABA','SOROCABA','SOROCABA','SOROCABA','SOROCABA','SOROCABA','SOROCABA','SOROCABA','SOROCABA','SOROCABA','SOROCABA','SOROCABA','SOROCABA','SOROCABA','SOROCABA','SOROCABA','SOROCABA','SOROCABA','SOROCABA','SOROCABA','SOROCABA','SOROCABA','SOROCABA','SOROCABA','SOROCABA','SOROCABA','SOROCABA','SOROCABA','SOROCABA','SOROCABA','SOROCABA','SOROCABA','SOROCABA','SOROCABA','SOROCABA','SOROCABA','SOROCABA','SOROCABA','SOROCABA','SOROCABA','SOROCABA','SOROCABA','SOROCABA','SOROCABA','SOROCABA','SOROCABA','TAUBATE','TAUBATE','TAUBATE','TAUBATE','TAUBATE','TAUBATE','TAUBATE','TAUBATE','TAUBATE','TAUBATE','TAUBATE','TAUBATE','TAUBATE','TAUBATE','TAUBATE','TAUBATE','TAUBATE','TAUBATE','TAUBATE','TAUBATE','TAUBATE','TAUBATE','TAUBATE','TAUBATE','TAUBATE','TAUBATE','TAUBATE','TAUBATE','TAUBATE','TAUBATE','TAUBATE','TAUBATE','TAUBATE','TAUBATE','TAUBATE','TAUBATE','TAUBATE','TAUBATE','TAUBATE'],
      'COD_GVE':['8','10','8','9','9','10','10','7','10','10','8','9','9','8','8','10','10','8','10','10','9','7','8','10','10','8','7','7','8','8','10','7','7','7','10','1','8','10','10','11','11','11','11','11','11','11','11','11','11','11','11','11','11','11','11','11','11','11','11','11','11','11','11','11','11','11','11','11','11','11','11','11','11','11','11','11','11','11','11','12','12','12','12','12','12','12','12','12','12','12','12','12','12','12','12','12','12','12','12','12','12','12','12','25','25','25','25','25','25','25','25','25','14','14','14','14','14','14','14','14','14','14','14','14','14','14','14','14','14','14','16','15','16','16','15','16','15','16','15','16','15','15','15','15','16','15','15','16','15','15','15','16','16','16','15','15','16','15','15','15','16','15','16','15','16','15','16','15','16','15','15','15','15','16','15','16','16','15','15','16','16','15','15','15','16','16','15','15','15','15','16','16','16','16','16','16','15','15','17','17','17','17','17','17','17','17','17','17','17','17','17','17','17','17','17','17','17','17','17','17','17','17','17','17','17','17','17','17','17','17','17','17','17','17','17','17','17','17','17','17','18','18','18','18','18','18','18','18','18','18','18','18','18','18','18','18','18','18','18','18','18','18','19','19','19','19','13','19','13','13','19','13','13','13','13','19','13','19','19','13','19','19','19','19','19','19','13','19','13','19','19','19','13','13','19','19','19','13','19','19','19','13','19','13','13','19','13','13','19','19','19','19','13','19','19','19','13','13','13','13','13','19','19','19','20','20','20','20','20','20','20','20','20','20','20','20','20','20','20','20','20','20','20','20','20','20','20','20','20','20','21','21','21','21','22','22','21','21','22','22','21','21','22','21','22','22','21','22','22','21','21','22','22','22','22','22','21','21','22','21','22','21','21','21','21','22','21','22','21','21','22','21','21','22','22','23','23','23','23','23','23','23','23','23','23','23','23','23','23','23','24','24','24','24','24','24','24','24','24','24','24','24','24','24','24','24','24','24','24','24','24','24','24','24','24','24','26','26','26','26','26','26','26','26','26','26','26','26','26','26','26','26','26','26','26','26','29','29','29','30','29','30','29','29','29','29','29','29','29','30','30','29','29','30','29','30','29','29','29','29','30','29','29','30','29','29','29','29','30','29','29','30','29','29','30','29','30','30','30','29','29','29','29','29','29','29','29','30','29','29','29','29','29','30','29','29','30','29','30','29','29','30','29','29','29','29','30','29','30','29','29','30','29','29','30','30','30','30','30','30','30','30','30','29','29','29','29','30','30','29','29','29','30','29','29','30','29','29','31','31','31','32','31','31','32','31','32','32','31','31','31','31','31','32','31','31','31','32','32','31','32','32','32','31','31','31','32','31','31','31','31','32','32','31','32','31','31','31','31','31','31','31','32','31','31','31','33','33','33','33','27','33','33','33','28','33','33','33','27','28','27','27','33','33','33','27','33','27','33','33','33','33','33','33','27','33','33','33','27','33','28','33','33','33','28'],
      'GVE_NOME':['MOGI DAS CRUZES','OSASCO','MOGI DAS CRUZES','FRANCO DA ROCHA','FRANCO DA ROCHA','OSASCO','OSASCO','SANTO ANDRE','OSASCO','OSASCO','MOGI DAS CRUZES','FRANCO DA ROCHA','FRANCO DA ROCHA','MOGI DAS CRUZES','MOGI DAS CRUZES','OSASCO','OSASCO','MOGI DAS CRUZES','OSASCO','OSASCO','FRANCO DA ROCHA','SANTO ANDRE','MOGI DAS CRUZES','OSASCO','OSASCO','MOGI DAS CRUZES','SANTO ANDRE','SANTO ANDRE','MOGI DAS CRUZES','MOGI DAS CRUZES','OSASCO','SANTO ANDRE','SANTO ANDRE','SANTO ANDRE','OSASCO','CAPITAL','MOGI DAS CRUZES','OSASCO','OSASCO','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARACATUBA','ARARAQUARA','ARARAQUARA','ARARAQUARA','ARARAQUARA','ARARAQUARA','ARARAQUARA','ARARAQUARA','ARARAQUARA','ARARAQUARA','ARARAQUARA','ARARAQUARA','ARARAQUARA','ARARAQUARA','ARARAQUARA','ARARAQUARA','ARARAQUARA','ARARAQUARA','ARARAQUARA','ARARAQUARA','ARARAQUARA','ARARAQUARA','ARARAQUARA','ARARAQUARA','ARARAQUARA','SANTOS','SANTOS','SANTOS','SANTOS','SANTOS','SANTOS','SANTOS','SANTOS','SANTOS','BARRETOS','BARRETOS','BARRETOS','BARRETOS','BARRETOS','BARRETOS','BARRETOS','BARRETOS','BARRETOS','BARRETOS','BARRETOS','BARRETOS','BARRETOS','BARRETOS','BARRETOS','BARRETOS','BARRETOS','BARRETOS','BOTUCATU','BAURU','BOTUCATU','BOTUCATU','BAURU','BOTUCATU','BAURU','BOTUCATU','BAURU','BOTUCATU','BAURU','BAURU','BAURU','BAURU','BOTUCATU','BAURU','BAURU','BOTUCATU','BAURU','BAURU','BAURU','BOTUCATU','BOTUCATU','BOTUCATU','BAURU','BAURU','BOTUCATU','BAURU','BAURU','BAURU','BOTUCATU','BAURU','BOTUCATU','BAURU','BOTUCATU','BAURU','BOTUCATU','BAURU','BOTUCATU','BAURU','BAURU','BAURU','BAURU','BOTUCATU','BAURU','BOTUCATU','BOTUCATU','BAURU','BAURU','BOTUCATU','BOTUCATU','BAURU','BAURU','BAURU','BOTUCATU','BOTUCATU','BAURU','BAURU','BAURU','BAURU','BOTUCATU','BOTUCATU','BOTUCATU','BOTUCATU','BOTUCATU','BOTUCATU','BAURU','BAURU','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','CAMPINAS','FRANCA','FRANCA','FRANCA','FRANCA','FRANCA','FRANCA','FRANCA','FRANCA','FRANCA','FRANCA','FRANCA','FRANCA','FRANCA','FRANCA','FRANCA','FRANCA','FRANCA','FRANCA','FRANCA','FRANCA','FRANCA','FRANCA','MARILIA','MARILIA','MARILIA','MARILIA','ASSIS','MARILIA','ASSIS','ASSIS','MARILIA','ASSIS','ASSIS','ASSIS','ASSIS','MARILIA','ASSIS','MARILIA','MARILIA','ASSIS','MARILIA','MARILIA','MARILIA','MARILIA','MARILIA','MARILIA','ASSIS','MARILIA','ASSIS','MARILIA','MARILIA','MARILIA','ASSIS','ASSIS','MARILIA','MARILIA','MARILIA','ASSIS','MARILIA','MARILIA','MARILIA','ASSIS','MARILIA','ASSIS','ASSIS','MARILIA','ASSIS','ASSIS','MARILIA','MARILIA','MARILIA','MARILIA','ASSIS','MARILIA','MARILIA','MARILIA','ASSIS','ASSIS','ASSIS','ASSIS','ASSIS','MARILIA','MARILIA','MARILIA','PIRACICABA','PIRACICABA','PIRACICABA','PIRACICABA','PIRACICABA','PIRACICABA','PIRACICABA','PIRACICABA','PIRACICABA','PIRACICABA','PIRACICABA','PIRACICABA','PIRACICABA','PIRACICABA','PIRACICABA','PIRACICABA','PIRACICABA','PIRACICABA','PIRACICABA','PIRACICABA','PIRACICABA','PIRACICABA','PIRACICABA','PIRACICABA','PIRACICABA','PIRACICABA','PRESIDENTE PRUDENTE','PRESIDENTE PRUDENTE','PRESIDENTE PRUDENTE','PRESIDENTE PRUDENTE','PRESIDENTE VENCESLAU','PRESIDENTE VENCESLAU','PRESIDENTE PRUDENTE','PRESIDENTE PRUDENTE','PRESIDENTE VENCESLAU','PRESIDENTE VENCESLAU','PRESIDENTE PRUDENTE','PRESIDENTE PRUDENTE','PRESIDENTE VENCESLAU','PRESIDENTE PRUDENTE','PRESIDENTE VENCESLAU','PRESIDENTE VENCESLAU','PRESIDENTE PRUDENTE','PRESIDENTE VENCESLAU','PRESIDENTE VENCESLAU','PRESIDENTE PRUDENTE','PRESIDENTE PRUDENTE','PRESIDENTE VENCESLAU','PRESIDENTE VENCESLAU','PRESIDENTE VENCESLAU','PRESIDENTE VENCESLAU','PRESIDENTE VENCESLAU','PRESIDENTE PRUDENTE','PRESIDENTE PRUDENTE','PRESIDENTE VENCESLAU','PRESIDENTE PRUDENTE','PRESIDENTE VENCESLAU','PRESIDENTE PRUDENTE','PRESIDENTE PRUDENTE','PRESIDENTE PRUDENTE','PRESIDENTE PRUDENTE','PRESIDENTE VENCESLAU','PRESIDENTE PRUDENTE','PRESIDENTE VENCESLAU','PRESIDENTE PRUDENTE','PRESIDENTE PRUDENTE','PRESIDENTE VENCESLAU','PRESIDENTE PRUDENTE','PRESIDENTE PRUDENTE','PRESIDENTE VENCESLAU','PRESIDENTE VENCESLAU','REGISTRO','REGISTRO','REGISTRO','REGISTRO','REGISTRO','REGISTRO','REGISTRO','REGISTRO','REGISTRO','REGISTRO','REGISTRO','REGISTRO','REGISTRO','REGISTRO','REGISTRO','RIBEIRAO PRETO','RIBEIRAO PRETO','RIBEIRAO PRETO','RIBEIRAO PRETO','RIBEIRAO PRETO','RIBEIRAO PRETO','RIBEIRAO PRETO','RIBEIRAO PRETO','RIBEIRAO PRETO','RIBEIRAO PRETO','RIBEIRAO PRETO','RIBEIRAO PRETO','RIBEIRAO PRETO','RIBEIRAO PRETO','RIBEIRAO PRETO','RIBEIRAO PRETO','RIBEIRAO PRETO','RIBEIRAO PRETO','RIBEIRAO PRETO','RIBEIRAO PRETO','RIBEIRAO PRETO','RIBEIRAO PRETO','RIBEIRAO PRETO','RIBEIRAO PRETO','RIBEIRAO PRETO','RIBEIRAO PRETO','SAO JOAO DA BOA VISTA','SAO JOAO DA BOA VISTA','SAO JOAO DA BOA VISTA','SAO JOAO DA BOA VISTA','SAO JOAO DA BOA VISTA','SAO JOAO DA BOA VISTA','SAO JOAO DA BOA VISTA','SAO JOAO DA BOA VISTA','SAO JOAO DA BOA VISTA','SAO JOAO DA BOA VISTA','SAO JOAO DA BOA VISTA','SAO JOAO DA BOA VISTA','SAO JOAO DA BOA VISTA','SAO JOAO DA BOA VISTA','SAO JOAO DA BOA VISTA','SAO JOAO DA BOA VISTA','SAO JOAO DA BOA VISTA','SAO JOAO DA BOA VISTA','SAO JOAO DA BOA VISTA','SAO JOAO DA BOA VISTA','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','JALES','SAO JOSE DO RIO PRETO','JALES','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','JALES','JALES','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','JALES','SAO JOSE DO RIO PRETO','JALES','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','JALES','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','JALES','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','JALES','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','JALES','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','JALES','SAO JOSE DO RIO PRETO','JALES','JALES','JALES','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','JALES','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','JALES','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','JALES','SAO JOSE DO RIO PRETO','JALES','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','JALES','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','JALES','SAO JOSE DO RIO PRETO','JALES','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','JALES','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','JALES','JALES','JALES','JALES','JALES','JALES','JALES','JALES','JALES','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','JALES','JALES','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','JALES','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','JALES','SAO JOSE DO RIO PRETO','SAO JOSE DO RIO PRETO','SOROCABA','SOROCABA','SOROCABA','ITAPEVA','SOROCABA','SOROCABA','ITAPEVA','SOROCABA','ITAPEVA','ITAPEVA','SOROCABA','SOROCABA','SOROCABA','SOROCABA','SOROCABA','ITAPEVA','SOROCABA','SOROCABA','SOROCABA','ITAPEVA','ITAPEVA','SOROCABA','ITAPEVA','ITAPEVA','ITAPEVA','SOROCABA','SOROCABA','SOROCABA','ITAPEVA','SOROCABA','SOROCABA','SOROCABA','SOROCABA','ITAPEVA','ITAPEVA','SOROCABA','ITAPEVA','SOROCABA','SOROCABA','SOROCABA','SOROCABA','SOROCABA','SOROCABA','SOROCABA','ITAPEVA','SOROCABA','SOROCABA','SOROCABA','TAUBATE','TAUBATE','TAUBATE','TAUBATE','SAO JOSE DOS CAMPOS','TAUBATE','TAUBATE','TAUBATE','CARAGUATATUBA','TAUBATE','TAUBATE','TAUBATE','SAO JOSE DOS CAMPOS','CARAGUATATUBA','SAO JOSE DOS CAMPOS','SAO JOSE DOS CAMPOS','TAUBATE','TAUBATE','TAUBATE','SAO JOSE DOS CAMPOS','TAUBATE','SAO JOSE DOS CAMPOS','TAUBATE','TAUBATE','TAUBATE','TAUBATE','TAUBATE','TAUBATE','SAO JOSE DOS CAMPOS','TAUBATE','TAUBATE','TAUBATE','SAO JOSE DOS CAMPOS','TAUBATE','CARAGUATATUBA','TAUBATE','TAUBATE','TAUBATE','CARAGUATATUBA'],
      'LAT':['-23,3965',	'-23,5057',	'-23,5698',	'-23,3607',	'-23,355',	'-23,5235',	'-23,6022',	'-23,6813',	'-23,6437',	'-23,8297',	'-23,5411',	'-23,2792',	'-23,3229',	'-23,4112',	'-23,4538',	'-23,7161',	'-23,5488',	'-23,4835',	'-23,5275',	'-23,9244',	'-23,3171',	'-23,6677',	'-23,5208',	'-23,5324',	'-23,3965',	'-23,5333',	'-23,7067',	'-23,7437',	'-23,5288',	'-23,3172',	'-23,4439',	'-23,6737',	'-23,6914',	'-23,6229',	'-23,8491',	'-23,5329',	'-23,5448',	'-23,6019',	'-23,5993',	'-21,5811',	'-20,8948',	'-21,2076',	'-20,6836',	'-21,4584',	'-21,2657',	'-21,2686',	'-21,404',	'-21,291',	'-21,499',	'-21,1651',	'-21,0661',	'-20,8689',	'-21,5604',	'-21,3521',	'-21,5294',	'-21,3812',	'-21,0292',	'-21,2544',	'-20,6467',	'-20,4326',	'-20,6419',	'-21,1639',	'-20,966',	'-21,6737',	'-21,1313',	'-20,9908',	'-20,7615',	'-21,1026',	'-20,856',	'-21,4148',	'-20,6368',	'-21,5921',	'-21,3006',	'-20,9331',	'-21,6376',	'-20,6872',	'-20,4981',	'-20,9428',	'-21,2229',	'-21,7288',	'-21,7845',	'-21,9918',	'-21,6214',	'-21,3275',	'-21,9002',	'-21,5155',	'-22,1044',	'-21,8367',	'-21,9584',	'-21,7562',	'-21,5942',	'-21,6025',	'-21,5103',	'-21,7765',	'-21,8498',	'-22,0685',	'-21,5894',	'-21,4618',	'-21,685',	'-22,0174',	'-21,7239',	'-21,4049',	'-22,0388',	'-23,8486',	'-23,8911',	'-23,9888',	'-24,1736',	'-24,0809',	'-24,312',	'-24,0084',	'-23,9535',	'-23,9574',	'-20,5242',	'-20,5531',	'-20,9491',	'-20,8773',	'-20,7114',	'-20,1768',	'-20,3196',	'-20,4977',	'-20,6884',	'-20,9065',	'-20,7366',	'-20,8108',	'-21,1431',	'-21,1223',	'-21,0737',	'-20,787',	'-20,8734',	'-21,1692',	'-22,8812',	'-22,4694',	'-22,793',	'-23,1386',	'-22,031',	'-22,6672',	'-22,1514',	'-23,1067',	'-21,8963',	'-23,6284',	'-22,073',	'-22,4909',	'-22,3246',	'-22,1365',	'-23,1055',	'-22,1926',	'-22,5728',	'-22,8837',	'-22,2795',	'-22,4576',	'-21,8031',	'-23,038',	'-23,0154',	'-23,6261',	'-22,3673',	'-22,4146',	'-23,3916',	'-21,7961',	'-21,6195',	'-21,8896',	'-22,8682',	'-22,509',	'-23,4213',	'-21,9857',	'-23,7043',	'-22,2324',	'-23,1047',	'-22,2936',	'-23,0506',	'-22,6027',	'-21,6718',	'-22,4294',	'-22,5002',	'-23,0056',	'-22,412',	'-23,3862',	'-23,0841',	'-22,5768',	'-22,3511',	'-23,0804',	'-23,1981',	'-21,999',	'-22,4142',	'-21,7396',	'-23,1761',	'-22,8112',	'-22,0999',	'-21,5356',	'-21,8914',	'-21,4593',	'-22,7321',	'-23,2721',	'-23,4452',	'-23,5307',	'-23,3425',	'-23,2462',	'-22,4237',	'-21,7866',	'-22,4733',	'-22,7374',	'-22,7088',	'-22,5727',	'-23,1171',	'-23,1356',	'-22,9527',	'-23,3053',	'-22,9053',	'-23,2078',	'-22,6419',	'-22,6405',	'-22,8529',	'-23,0816',	'-23,0035',	'-23,1526',	'-22,7037',	'-23,1039',	'-22,927',	'-23,1852',	'-22,5226',	'-23,0856',	'-22,6817',	'-22,945',	'-22,8811',	'-23,1747',	'-22,7832',	'-22,7542',	'-22,7902',	'-22,7413',	'-22,7811',	'-23,0525',	'-22,7553',	'-22,6029',	'-22,6139',	'-22,5903',	'-22,8204',	'-22,8193',	'-22,9698',	'-22,887',	'-23,2136',	'-23,0302',	'-20,0882',	'-20,1911',	'-20,4036',	'-20,5352',	'-20,4302',	'-20,0407',	'-20,4438',	'-20,6416',	'-20,3355',	'-20,3116',	'-20,1796',	'-20,7288',	'-20,7296',	'-20,7169',	'-20,6384',	'-20,2535',	'-20,6056',	'-20,4579',	'-20,0803',	'-20,7696',	'-20,5812',	'-20,5935',	'-21,682',	'-22,0841',	'-22,4435',	'-21,7728',	'-22,66',	'-21,921',	'-23,0164',	'-22,2696',	'-22,602',	'-22,7471',	'-23,004',	'-23,0366',	'-22,7373',	'-22,4326',	'-22,6925',	'-22,3607',	'-21,6127',	'-22,868',	'-22,2918',	'-22,2125',	'-21,9091',	'-21,8942',	'-22,0038',	'-21,8572',	'-22,8185',	'-21,7695',	'-23,0575',	'-22,0112',	'-21,7182',	'-22,4146',	'-22,3384',	'-22,6149',	'-21,7959',	'-22,2171',	'-22,438',	'-22,9435',	'-22,1549',	'-22,3149',	'-21,7968',	'-22,9797',	'-21,5627',	'-22,7858',	'-22,4114',	'-21,7792',	'-22,8174',	'-22,6371',	'-22,107',	'-21,8496',	'-21,7969',	'-22,0692',	'-22,789',	'-21,7284',	'-21,8823',	'-21,6267',	'-22,8894',	'-22,8988',	'-22,7453',	'-22,7429',	'-23,2057',	'-21,9335',	'-22,5272',	'-22,2183',	'-22,5977',	'-22,1289',	'-22,3572',	'-22,9951',	'-22,5096',	'-22,3375',	'-22,4778',	'-22,2213',	'-23,0428',	'-22,4836',	'-22,4355',	'-22,5832',	'-22,2562',	'-22,1809',	'-22,566',	'-22,9285',	'-22,7338',	'-21,996',	'-23,0105',	'-22,3984',	'-22,8417',	'-22,8442',	'-22,1405',	'-22,4572',	'-22,5661',	'-22,5483',	'-21,9527',	'-22,0764',	'-22,2934',	'-22,0127',	'-21,8322',	'-21,4843',	'-21,8314',	'-22,4859',	'-22,5545',	'-21,6727',	'-22,6602',	'-22,1738',	'-21,5684',	'-22,2473',	'-21,5103',	'-22,1068',	'-22,1462',	'-22,2904',	'-21,2981',	'-22,6156',	'-22,4057',	'-21,332',	'-21,4872',	'-21,354',	'-21,3153',	'-21,8747',	'-22,2711',	'-22,0082',	'-21,7651',	'-22,1207',	'-21,8732',	'-22,2456',	'-22,2269',	'-22,2181',	'-21,8382',	'-22,5782',	'-22,4551',	'-21,3495',	'-21,9747',	'-21,8467',	'-21,2662',	'-22,3866',	'-22,3016',	'-22,5299',	'-21,3825',	'-24,759',	'-24,7324',	'-25,0144',	'-24,5281',	'-24,699',	'-24,7307',	'-24,5847',	'-24,2834',	'-24,6963',	'-24,3101',	'-24,2766',	'-24,7147',	'-24,2764',	'-24,4979',	'-24,382',	'-21,0214',	'-21,1864',	'-20,8929',	'-20,9845',	'-21,2749',	'-21,2801',	'-21,338',	'-21,2324',	'-21,3594',	'-21,4944',	'-21,252',	'-21,0176',	'-21,55',	'-21,2655',	'-21,0132',	'-21,0216',	'-21,3626',	'-21,1699',	'-21,2951',	'-21,7083',	'-21,4776',	'-21,0864',	'-21,4732',	'-21,3074',	'-21,2043',	'-21,1316',	'-22,0572',	'-21,9319',	'-21,528',	'-21,7708',	'-21,6637',	'-22,1909',	'-22,2713',	'-22,4357',	'-21,7309',	'-21,4647',	'-22,3675',	'-22,4332',	'-21,8235',	'-22,1121',	'-21,9707',	'-21,5953',	'-21,7041',	'-21,7029',	'-21,4713',	'-21,8322',	'-21,2325',	'-20,3203',	'-20,2985',	'-20,4487',	'-21,1872',	'-20,16',	'-20,9197',	'-20,7348',	'-20,08',	'-21,1314',	'-21,0519',	'-20,9009',	'-20,4755',	'-20,4642',	'-20,124',	'-21,1678',	'-20,9796',	'-20,2875',	'-21,2661',	'-20,2806',	'-20,6752',	'-20,7948',	'-20,6485',	'-20,7959',	'-20,0746',	'-21,083',	'-20,3391',	'-19,979',	'-20,6557',	'-21,2768',	'-21,3123',	'-20,8805',	'-20,2672',	'-21,0551',	'-20,8022',	'-20,1444',	'-20,6445',	'-21,2587',	'-20,4389',	'-21,1757',	'-20,3579',	'-19,9684',	'-19,9789',	'-20,8169',	'-20,6179',	'-20,8509',	'-20,768',	'-20,843',	'-20,6945',	'-20,9114',	'-21,0156',	'-20,3836',	'-20,5321',	'-20,9893',	'-21,4651',	'-20,6042',	'-20,1861',	'-20,0061',	'-20,39',	'-21,0854',	'-20,4148',	'-21,0159',	'-20,1048',	'-20,3034',	'-20,0296',	'-20,2474',	'-21,1853',	'-21,0886',	'-21,0342',	'-20,7829',	'-20,4396',	'-20,1727',	'-19,9453',	'-21,0428',	'-19,9868',	'-20,1759',	'-21,3427',	'-21,2427',	'-20,0311',	'-20,09',	'-20,2083',	'-20,1414',	'-20,2429',	'-20,2523',	'-20,3623',	'-20,3879',	'-20,5111',	'-20,8113',	'-20,6523',	'-20,9602',	'-20,6228',	'-20,2344',	'-20,0486',	'-21,165',	'-20,9511',	'-20,8862',	'-20,2455',	'-21,2032',	'-20,4217',	'-20,1956',	'-20,4237',	'-21,0506',	'-23,5503',	'-23,5306',	'-23,4917',	'-24,5108',	'-23,4366',	'-23,5029',	'-24,4722',	'-23,2855',	'-24,3155',	'-23,7977',	'-23,5895',	'-24,0113',	'-23,4685',	'-23,1665',	'-23,226',	'-24,1892',	'-23,3714',	'-23,6596',	'-23,3513',	'-23,8638',	'-24,6393',	'-23,5886',	'-23,9788',	'-24,572',	'-24,1085',	'-23,2544',	'-23,0884',	'-23,5398',	'-24,1224',	'-23,7139',	'-23,8077',	'-23,2093',	'-23,2993',	'-24,6517',	'-24,2206',	'-24,1011',	'-23,829',	'-23,1996',	'-23,6474',	'-23,8782',	'-23,5226',	'-23,6397',	'-23,4969',	'-23,9612',	'-23,9211',	'-23,3487',	'-23,1101',	'-23,5446',	'-22,8495',	'-22,6717',	'-22,5786',	'-22,6819',	'-23,0992',	'-22,6665',	'-22,7296',	'-22,7003',	'-23,6125',	'-22,5728',	'-23,0731',	'-22,8075',	'-23,2037',	'-23,7785',	'-23,2983',	'-23,2522',	'-23,0846',	'-22,57',	'-22,7334',	'-22,9544',	'-23,3707',	'-23,3872',	'-22,9246',	'-22,6069',	'-22,8343',	'-22,5312',	'-23,2638',	'-22,8938',	'-23,3933',	'-22,827',	'-22,6837',	'-22,6414',	'-23,1896',	'-23,222',	'-23,7951',	'-22,6638',	'-23,0104',	'-22,9571',	'-23,4332'],
      'LON':['-46,32',	'-46,879',	'-46,0407',	'-46,7397',	'-46,8781',	'-46,8407',	'-46,919',	'-46,6205',	'-46,8579',	'-46,8136',	'-46,371',	'-46,7448',	'-46,729',	'-46,0369',	'-46,5333',	'-46,8572',	'-46,9327',	'-46,3457',	'-46,9023',	'-47,0653',	'-46,5897',	'-46,4613',	'-46,1854',	'-46,7916',	'-46,9991',	'-46,3473',	'-46,4058',	'-46,3971',	'-45,8465',	'-46,2237',	'-46,9178',	'-46,5432',	'-46,5646',	'-46,5548',	'-46,9432',	'-46,6395',	'-46,3112',	'-46,7526',	'-47,022',	'-50,168',	'-51,3786',	'-50,4401',	'-50,5572',	'-49,9509',	'-49,9518',	'-50,814',	'-50,4746',	'-50,3432',	'-50,3175',	'-50,1861',	'-50,1475',	'-51,4884',	'-50,4525',	'-50,2859',	'-50,5573',	'-50,2123',	'-51,2119',	'-50,6453',	'-50,6645',	'-51,3426',	'-51,5063',	'-51,0412',	'-50,2263',	'-50,3294',	'-51,1035',	'-51,2774',	'-50,3477',	'-51,4905',	'-50,2617',	'-50,0769',	'-51,1123',	'-50,6003',	'-50,7296',	'-50,498',	'-50,5044',	'-50,9238',	'-51,0268',	'-50,1135',	'-50,8699',	'-48,1147',	'-48,178',	'-48,3906',	'-49,0741',	'-48,6327',	'-47,6181',	'-48,3935',	'-48,3178',	'-48,4957',	'-47,9882',	'-48,8319',	'-48,8149',	'-48,364',	'-48,1538',	'-48,5705',	'-47,487',	'-48,182',	'-48,0728',	'-48,3953',	'-48,0885',	'-47,886',	'-48,6896',	'-48,5103',	'-48,3342',	'-46,1396',	'-46,424',	'-46,258',	'-46,788',	'-46,6265',	'-47,0012',	'-46,4121',	'-46,335',	'-46,3883',	'-49,0571',	'-48,5698',	'-48,4791',	'-48,8063',	'-48,5387',	'-48,6865',	'-48,312',	'-48,9391',	'-48,4112',	'-48,6387',	'-48,9106',	'-48,8054',	'-48,5112',	'-48,4528',	'-48,4126',	'-48,3314',	'-48,293',	'-48,6284',	'-49,2421',	'-48,9863',	'-48,1336',	'-49,0487',	'-48,9135',	'-48,6681',	'-49,3356',	'-48,9251',	'-49,3619',	'-49,5634',	'-48,7438',	'-48,5583',	'-49,0871',	'-48,523',	'-48,2582',	'-48,7808',	'-48,9707',	'-48,4437',	'-48,1251',	'-49,3393',	'-49,6092',	'-49,1655',	'-48,0134',	'-49,31',	'-48,3819',	'-49,4084',	'-49,5124',	'-49,9312',	'-49,8013',	'-49,031',	'-49,1634',	'-48,5597',	'-49,092',	'-48,8116',	'-49,4819',	'-48,7197',	'-48,6157',	'-48,5592',	'-47,8375',	'-48,8037',	'-49,7526',	'-49,522',	'-48,7102',	'-49,3202',	'-48,451',	'-48,7214',	'-48,3679',	'-49,4008',	'-48,7781',	'-47,972',	'-49,3803',	'-49,4608',	'-49,1339',	'-49,3604',	'-48,1195',	'-48,6636',	'-49,4381',	'-49,8599',	'-49,2268',	'-49,5755',	'-48,5723',	'-49,4763',	'-49,4024',	'-49,241',	'-49,3722',	'-48,1955',	'-48,1731',	'-49,2848',	'-46,6314',	'-47,3331',	'-46,772',	'-47,1727',	'-46,5563',	'-46,4675',	'-46,5419',	'-47,1362',	'-47,0659',	'-46,7889',	'-47,1926',	'-47,0487',	'-47,2143',	'-47,2101',	'-46,8464',	'-47,0593',	'-46,9851',	'-46,728',	'-46,2741',	'-46,8974',	'-46,65',	'-46,9484',	'-46,681',	'-47,3122',	'-46,7896',	'-46,3983',	'-47,2941',	'-47,1488',	'-46,4455',	'-46,8948',	'-46,5897',	'-46,3594',	'-47,4143',	'-46,9192',	'-46,7033',	'-46,5251',	'-47,2728',	'-46,6937',	'-46,9974',	'-46,4124',	'-46,8234',	'-46,9833',	'-47,7873',	'-47,7096',	'-47,4209',	'-47,4039',	'-47,8236',	'-47,7466',	'-48,0129',	'-47,2194',	'-47,7902',	'-47,5918',	'-48,031',	'-48,0581',	'-47,7429',	'-47,8852',	'-47,2801',	'-47,4775',	'-47,4833',	'-47,5904',	'-47,4291',	'-47,8369',	'-47,8593',	'-47,6424',	'-51,0737',	'-49,719',	'-49,7623',	'-50,466',	'-50,4183',	'-50,7357',	'-49,4679',	'-50,5409',	'-49,9987',	'-50,3873',	'-49,7839',	'-49,7096',	'-50,7909',	'-50,2038',	'-49,4341',	'-49,5187',	'-51,1724',	'-50,6814',	'-49,5504',	'-49,6546',	'-49,8986',	'-49,5914',	'-50,3907',	'-50,6932',	'-50,0739',	'-50,9633',	'-49,6279',	'-49,7873',	'-51,0215',	'-49,818',	'-50,394',	'-50,6713',	'-51,1824',	'-49,9501',	'-49,922',	'-49,3419',	'-50,0971',	'-50,2811',	'-50,8793',	'-49,8697',	'-51,2654',	'-50,218',	'-50,5732',	'-50,7949',	'-50,7933',	'-50,2104',	'-50,176',	'-51,0868',	'-50,2415',	'-50,307',	'-49,933',	'-50,7239',	'-50,9594',	'-50,8614',	'-49,9831',	'-49,6354',	'-49,7428',	'-50,5786',	'-49,6096',	'-50,5191',	'-49,6613',	'-49,8207',	'-47,8734',	'-47,6619',	'-47,3842',	'-47,5071',	'-47,7755',	'-47,1729',	'-47,4519',	'-47,6215',	'-47,3682',	'-47,211',	'-47,7151',	'-47,523',	'-47,8166',	'-47,3841',	'-47,397',	'-47,559',	'-47,6476',	'-47,4257',	'-47,5318',	'-47,5546',	'-47,6047',	'-47,6754',	'-47,4512',	'-47,5272',	'-48,1593',	'-47,9096',	'-51,414',	'-51,4722',	'-51,3895',	'-51,2394',	'-51,9969',	'-51,535',	'-51,4832',	'-51,6632',	'-52,5928',	'-51,3821',	'-51,0779',	'-51,2555',	'-51,3472',	'-50,7694',	'-51,4342',	'-51,9617',	'-51,1709',	'-51,9084',	'-51,5679',	'-51,24',	'-51,5274',	'-51,6447',	'-51,7024',	'-51,8562',	'-51,8321',	'-51,7282',	'-51,4976',	'-51,5565',	'-52,1111',	'-51,3925',	'-51,8447',	'-50,6966',	'-50,893',	'-51,3055',	'-51,6103',	'-53,0603',	'-51,7648',	'-51,7564',	'-51,6527',	'-51,3929',	'-51,6672',	'-51,2882',	'-51,5621',	'-52,1682',	'-51,575',	'-48,5013',	'-48,1223',	'-47,9341',	'-48,1141',	'-47,5537',	'-47,5383',	'-48,5971',	'-47,1736',	'-48,0064',	'-47,6426',	'-47,4625',	'-47,8742',	'-47,2354',	'-47,8449',	'-47,9279',	'-47,3712',	'-48,1636',	'-47,5921',	'-47,6572',	'-47,303',	'-47,1643',	'-47,7324',	'-47,9756',	'-48,2316',	'-48,0356',	'-48,3252',	'-47,7606',	'-47,7801',	'-48,4971',	'-48,221',	'-48,0423',	'-48,0679',	'-47,8099',	'-47,4304',	'-47,478',	'-47,3622',	'-47,1464',	'-47,5518',	'-47,5602',	'-47,5952',	'-47,9875',	'-46,9735',	'-46,7176',	'-46,6437',	'-47,0852',	'-46,7361',	'-46,7477',	'-46,9481',	'-46,8224',	'-46,9743',	'-47,0024',	'-46,9428',	'-46,9532',	'-47,248',	'-46,6845',	'-46,7944',	'-46,8873',	'-46,8208',	'-47,2703',	'-46,7448',	'-46,8913',	'-49,6451',	'-49,9141',	'-49,7359',	'-50,8835',	'-48,7904',	'-50,728',	'-49,4385',	'-49,5865',	'-49,9183',	'-48,977',	'-49,0616',	'-49,2664',	'-49,7827',	'-50,6073',	'-50,5149',	'-49,1146',	'-48,8325',	'-50,4049',	'-48,6874',	'-50,2471',	'-50,1513',	'-50,1912',	'-50,364',	'-49,2172',	'-50,3411',	'-49,2448',	'-49,1915',	'-50,2909',	'-49,3842',	'-49,4164',	'-49,0629',	'-49,5797',	'-50,5494',	'-49,6892',	'-49,9687',	'-50,1973',	'-50,2305',	'-49,13',	'-50,8254',	'-49,5791',	'-50,1811',	'-50,6326',	'-50,139',	'-49,5206',	'-49,4617',	'-50,0975',	'-49,7184',	'-49,6358',	'-50,0436',	'-49,7833',	'-49,4986',	'-50,9483',	'-49,3123',	'-48,9141',	'-49,2234',	'-49,2929',	'-49,3464',	'-50,3768',	'-49,4309',	'-48,8037',	'-50,7632',	'-48,7761',	'-50,5886',	'-50,0163',	'-49,4',	'-50,1129',	'-48,9086',	'-48,6607',	'-49,933',	'-49,8258',	'-50,5258',	'-49,7064',	'-50,538',	'-49,3815',	'-49,6836',	'-51,007',	'-49,4897',	'-48,8063',	'-50,7297',	'-50,9491',	'-50,932',	'-50,8358',	'-50,6887',	'-50,8014',	'-50,6952',	'-50,3792',	'-50,3561',	'-49,3758',	'-49,925',	'-49,0307',	'-49,6563',	'-50,8905',	'-50,4792',	'-49,7198',	'-49,1713',	'-49,9025',	'-50,6455',	'-49,2931',	'-50,0889',	'-50,4875',	'-49,9781',	'-50,0552',	'-47,898',	'-47,2546',	'-48,4139',	'-48,8443',	'-47,0608',	'-47,6166',	'-49,0238',	'-47,6786',	'-49,1451',	'-48,5958',	'-48,4758',	'-48,3482',	'-47,7388',	'-47,7459',	'-47,9545',	'-48,5295',	'-48,1837',	'-47,223',	'-47,6927',	'-49,14',	'-48,8413',	'-48,0483',	'-48,8764',	'-49,1661',	'-49,3352',	'-47,2927',	'-47,7868',	'-47,185',	'-48,9022',	'-47,4256',	'-47,7222',	'-47,5251',	'-48,0547',	'-49,0044',	'-48,7635',	'-48,3679',	'-49,429',	'-47,2931',	'-47,5743',	'-47,9935',	'-47,1357',	'-47,8249',	'-47,4451',	'-47,5062',	'-48,6948',	'-47,8461',	'-47,7164',	'-47,4388',	'-45,2325',	'-44,4441',	'-44,6992',	'-44,3281',	'-45,7076',	'-45,0154',	'-45,5833',	'-45,0521',	'-45,4125',	'-44,969',	'-44,9576',	'-45,1938',	'-46,157',	'-45,3552',	'-45,9658',	'-45,6942',	'-45,1944',	'-44,9024',	'-45,1197',	'-45,8407',	'-45,4468',	'-45,6639',	'-45,4613',	'-45,1869',	'-45,2552',	'-44,7781',	'-45,5422',	'-45,307',	'-45,8875',	'-45,663',	'-45,7287',	'-44,5774',	'-45,8841',	'-45,3109',	'-45,4143',	'-44,8522',	'-45,5593',	'-45,5475',	'-45,0834']
      }

# Criando o DataFrame para o GVE e DRS
df_font3 = pd.DataFrame(dataGVE_DRS)

# Exibindo as primeiras linhas do DataFrame resultante para verificar
display(df_font3.head())

# Convertendo para string e substituindo v√≠rgula por ponto
df_font3['LAT_'] = df_font3['LAT'].astype(str).str.replace(',', '.')
df_font3['LON_'] = df_font3['LON'].astype(str).str.replace(',', '.')

# Removendo o sinal de menos e unindo as colunas com uma v√≠rgula entre elas
#df_font3['LAT_LON'] = df_font3['LAT'].str.replace('-', '') + ', ' + df_font3['LON'].str.replace('-', '')

# Removendo unindo as colunas com uma v√≠rgula entre elas
df_font3['LAT_LON'] = df_font3['LAT_'] + ', ' + df_font3['LON_']


# Exibindo as primeiras linhas para verificar o resultado
display(df_font3[['LAT_', 'LON_', 'LAT_LON']].head())

num_linhas3 = df_font3.shape[0]
num_linhas3_formatado = "{:,}".format(num_linhas3).replace(",", ".")
print(f"O n√∫mero de linhas da FONTE_3 √©: {num_linhas3_formatado} = (munic√≠pios)")

df_font3.info()

"""### ‚úÖFONTE_4: GEO BR
GeoBR - https://github.com/ipeaGIT/geobr
"""

# Carregando base da GeoBr e Filtrando s√≥ os munic√≠pios da UF SP
mun = geobr.read_municipality(code_muni="SP", year=2022)

# Criando nova coluna tratada com a convers√£o da coluna para string e removendo o ponto e os caracteres ap√≥s ele
mun['CODE_MUNI_IBGE'] = mun['code_muni'].astype(str).str.split('.').str[0]

num_linhas0 = mun.shape[0]
num_linhas0_formatado = "{:,}".format(num_linhas0).replace(",", ".")
print(f"O n√∫mero de linhas da FONTE_4 √©: {num_linhas0_formatado} = (munic√≠pios)")

# Exibindo as primeiras linhas do DataFrame resultante para verificar
display(mun.head())

#Testando a visualiza√ß√£o do Estado de SP
gdf_mun0 = mun[mun.name_state == 'S√£o Paulo']
gdf_mun1 = mun[mun.name_state == 'S√£o Paulo']
gdf_mun2 = mun[mun.name_state == 'S√£o Paulo']

gdf_mun0.plot()

#Definindo o Sistema de proje√ß√£o
mun.crs = 'EPSG:4326'
mun.crs

df_font4 = mun

df_font4.info()

"""## üîÄ2.2 Linkage/Joins/Cruzamentos

### JOIN_01 = df_font3 + df_font4
Enriquecer a tabela com dados da GVE e DRS com informa√ß√µes dos MULTIPOLYGON da GeoBR
"""

# Tratando as colunas do MERGE para o mesmo tipo de dado (string)
df_font3['COD_MUNICIPIO_7']   = df_font3['COD_MUNICIPIO_7'].astype(str)
df_font4['CODE_MUNI_IBGE']    = df_font4['CODE_MUNI_IBGE'].astype(str)

# Realizando um left join entre df_font4 e df_font3
df_Join_01 = pd.merge(df_font4, df_font3, how='left', left_on='CODE_MUNI_IBGE', right_on='COD_MUNICIPIO_7')

# Excluindo as colunas que n√£o ser√£o necess√°rias
df_Join_01.drop(['COD_17DRS', 'COD_GVE'], axis=1, inplace=True)

# Renomeando as colunas especificadas
df_Join_01.rename(columns={'DRS_17': 'DRS', 'GVE_NOME': 'GVE'}, inplace=True)

# Exibindo as primeiras linhas do DataFrame resultante para verificar
display(df_Join_01.head())

num_linhas4 = df_Join_01.shape[0]
num_linhas4_formatado = "{:,}".format(num_linhas4).replace(",", ".")
print(f"O n√∫mero de linhas do JOIN(01) √©: {num_linhas4_formatado}")

#Definindo o Sistema de proje√ß√£o
df_Join_01.crs = 'EPSG:4326'
df_Join_01.crs

df_Join_01.info()

"""### JOIN(02) = df_font1 + df_Join_01
Enriquecimento da Fonte principal de an√°lise hist√≥rica para as previs√µes, com as informa√ß√µes de GVE, DRS e os MULTIPOLYGON
"""

# Tratando as colunas do MERGE para o mesmo tipo de dado (string)
df_font1['CODIGO_IBGE']         = df_font1['CODIGO_IBGE'].astype(str)
df_Join_01['COD_MUNICIPIO_7']   = df_Join_01['COD_MUNICIPIO_7'].astype(str)

# Realizando um left join entre df_font1 e df_Join_01
df_Join_02 = pd.merge(df_font1, df_Join_01, how='left', left_on='CODIGO_IBGE', right_on='COD_MUNICIPIO_7')

# Excluindo as colunas que n√£o ser√£o necess√°rias
df_Join_02.drop(['COD_MUNICIPIO_7'], axis=1, inplace=True)


# Exibindo as primeiras linhas do DataFrame resultante para verificar
display(df_Join_02.head())

num_linhas5 = df_Join_02.shape[0]
num_linhas5_formatado = "{:,}".format(num_linhas5).replace(",", ".")
print(f"O n√∫mero de linhas do JOIN(02) √©: {num_linhas5_formatado}")

#Definindo o Sistema de proje√ß√£o
df_Join_02.crs = 'EPSG:4326'
df_Join_02.crs

df_Join_02.info()

# Exibindo as primeiras linhas do DataFrame resultante para verificar
display(df_Join_02.head())

"""### JOIN(03)  df_font2 + df_Join_01
Enriquecer a Segunda fonte de dados de an√°lise, com as informa√ß√µes de GVE, DRS e os MULTIPOLYGON
"""

# 1¬∫ - Selecione as colunas especificadas do df_Join_02 para criar o dataFrame auxiliar (df_aux1)
df_aux1 = df_Join_02[['CODIGO_IBGE', 'LAT_', 'LON_', 'LAT_LON', 'DRS', 'GVE', 'code_muni', 'name_muni', 'code_state', 'abbrev_state', 'name_state', 'code_region', 'name_region', 'geometry']].copy()

num_linhas6 = df_aux1.shape[0]
num_linhas6_formatado = "{:,}".format(num_linhas6).replace(",", ".")
print(f"O n√∫mero de linhas do df_aux1 √©: {num_linhas6_formatado}")

# 2¬∫ - Agrupar e selecionar o valor m√°ximo para as colunas num√©ricas e o primeiro para as n√£o num√©ricas
aggregation_functions = {
    'LAT_': 'max',
    'LON_': 'max',
    'LAT_LON': 'max',
    'DRS': 'first',
    'GVE': 'first',
    'code_muni': 'first',
    'name_muni': 'first',
    'code_state': 'first',
    'abbrev_state': 'first',
    'name_state': 'first',
    'code_region': 'first',
    'name_region': 'first',
    'geometry': 'first'}
df_aux2 = df_aux1.groupby('CODIGO_IBGE').agg(aggregation_functions).reset_index()

# 3¬∫ - Renomeie a coluna CODIGO_IBGE para CODIGO_IBGE_temp
df_aux2.rename(columns={'CODIGO_IBGE': 'CODIGO_IBGE_temp'}, inplace=True)

num_linhas6 = df_aux2.shape[0]
print(f"O n√∫mero de linhas no df_aux2 √©: {num_linhas6}")

# Exibindo as primeiras linhas do DataFrame resultante para verificar
display(df_aux2.head())

# 4¬∫ - Realize um left join entre df_font2 e df_aux2
df_Join_03 = pd.merge(df_font2, df_aux2, how='left', left_on='CODIGO_IBGE', right_on='CODIGO_IBGE_temp')

# 5¬∫ - Remova a coluna CODIGO_IBGE_temp do df_Join_03
df_Join_03.drop('CODIGO_IBGE_temp', axis=1, inplace=True)

num_linhas8 = df_Join_03.shape[0]
num_linhas8_formatado = "{:,}".format(num_linhas8).replace(",", ".")
print(f"O n√∫mero de linhas do df_Join_03 √©: {num_linhas8_formatado}")

# Exibindo as primeiras linhas do DataFrame resultante para verificar
display(df_Join_03.head())

#Definindo o Sistema de proje√ß√£o
df_Join_03.crs = 'EPSG:4326'
df_Join_03.crs

df_Join_03.info()

"""# üìç3.An√°lise e Explora√ß√£o dos Dados

## üìäCASOS
Fonte de dados Principal de Casos e √ìbitos com s√©ria hist√≥ria de 2020-02-25 e 2023-11-01 e enriquecida com dimens√µes por DRS e GVE
DataFrame: df_Join_02

#### Vari√°veis
"""

# Configurando para usar o separador de milhares conforme a localidade do sistema
locale.setlocale(locale.LC_ALL, '')

# Coordenadas do centro de S√£o Paulo para os Mapas
coordenadas_centro_sp = [-23.550520, -46.633308]

"""###   An√°lise 1---| Linha hist√≥rica |
Nesse bloco de an√°lise, tamb√©m envolve os valores totais do per√≠odo de an√°lise e por categoria (Sexo, Ra√ßa/Cor e Idade)

1-Tend√™ncia de Casos ao Longo do Tempo:
"""

# Certifique-se de que a coluna 'DATAHORA' √© do tipo datetime
df_Join_02['DATAHORA'] = pd.to_datetime(df_Join_02['DATAHORA'])

# Agora, a opera√ß√£o de subtra√ß√£o deve funcionar, pois 'DATAHORA' √© do tipo datetime
df_Join_02['DATAHORA2'] = (df_Join_02['DATAHORA'] - df_Join_02['DATAHORA'].min()).dt.days

plt.figure(figsize=(15, 5))

# Usando a nova coluna 'DATAHORA2' para o eixo X
sns.lineplot(data=df_Join_02, x='DATAHORA2', y='CASOS_NOVOS', label='Casos Novos')

# Adicionando uma linha de tend√™ncia de regress√£o linear usando 'DATAHORA2'
sns.regplot(data=df_Join_02, x='DATAHORA2', y='CASOS_NOVOS', scatter=False, color='red', label='Linha de Tend√™ncia')

# Configurando o t√≠tulo e os r√≥tulos
plt.title('Tend√™ncia de Casos Novos ao Longo do Tempo')
plt.xlabel('Dias desde o in√≠cio da pandemia')
plt.ylabel('Quantidade')
plt.legend()
plt.show()

"""Evolu√ß√£o da M√©dia M√≥vel de 7 Dias para Casos"""

plt.figure(figsize=(15, 5))
sns.lineplot(data=df_Join_02, x='DATAHORA', y='CASOS_MM7D')
plt.title('Evolu√ß√£o da M√©dia M√≥vel de 7 Dias para Casos')
plt.xlabel('Data')
plt.ylabel('')
plt.legend()
plt.show()

"""#### Sexo"""

# Agrupando o df_Join_03 por 'CS_SEXO' e contando o total de registros para cada grupo
total_registros_por_grupo = df_Join_03.groupby(['CS_SEXO']).size().reset_index(name='TOTAL')

# Formatando os n√∫meros com separadores de milhares
total_registros_por_grupo['TOTAL_FORMATADO'] = total_registros_por_grupo['TOTAL'].apply(lambda x: f"{x:,}")

# Exibindo o resultado com os n√∫meros formatados
display(total_registros_por_grupo[['CS_SEXO', 'TOTAL_FORMATADO']])

"""Conferindo dos casos confirmados de COVID19 no Estado de SP quantos evoluiram √† √≥bito"""

# Agrupando o df_Join_03 por 'OBITO' e contando o total de registros para cada grupo, sendo False o total de CASOS Confirmados sem √≥bito
total_registros_por_obito = df_Join_03.groupby(['OBITO']).size().reset_index(name='TOTAL')

# Formatando os n√∫meros com separadores de milhares
total_registros_por_obito['TOTAL_FORMATADO'] = total_registros_por_obito['TOTAL'].apply(lambda x: f"{x:,}")

# Exibindo o resultado com os n√∫meros formatados
display(total_registros_por_obito[['OBITO', 'TOTAL_FORMATADO']])

"""Rela√ß√£o de Casos Confirmados (sem √≥bito) x Sexo

"""

# Filtrando apenas os casos onde OBITO √© False e CS_SEXO √© 'MASCULINO' ou 'FEMININO'
casos_sem_obito = df_Join_03[(df_Join_03['OBITO'] == False) & (df_Join_03['CS_SEXO'].isin(['MASCULINO', 'FEMININO']))]

# Agrupando o DataFrame filtrado por 'IDADE' e 'CS_SEXO' e contando os registros
total_registros_por_sexo_e_idade_sem_o = casos_sem_obito.groupby(['IDADE', 'CS_SEXO']).size().reset_index(name='TOTAL')

# Ordenando os resultados pelo 'TOTAL' em ordem decrescente
total_registros_por_sexo_e_idade_sem_o = total_registros_por_sexo_e_idade_sem_o.sort_values(by='TOTAL', ascending=False)

# Exibindo o resultado
display(total_registros_por_sexo_e_idade_sem_o)

"""Sexo x Idade"""

# Definindo o tamanho da figura
plt.figure(figsize=(20, 10))

# Criando o gr√°fico de barras
plt.bar(total_registros_por_sexo_e_idade_sem_o['IDADE'].astype(str) ,
        total_registros_por_sexo_e_idade_sem_o['TOTAL'],
        color=['blue' if sexo == 'MASCULINO' else 'pink' for sexo in total_registros_por_sexo_e_idade_sem_o['CS_SEXO']])

# Adicionando t√≠tulo e r√≥tulos aos eixos
plt.title('Total de Casos por Sexo e Idade')
plt.xlabel('Grupo de Idade e Sexo')
plt.ylabel('Total de Casos')

# Melhorando a visualiza√ß√£o das etiquetas do eixo x
plt.xticks(rotation=90)

# Mostrando o gr√°fico
plt.show()

"""Sexo apenas M e F"""

# Agregando os dados por sexo e somando os registros
total_por_sexo_sem_o = total_registros_por_sexo_e_idade_sem_o.groupby('CS_SEXO')['TOTAL'].sum().reset_index()

# Criando o gr√°fico de pizza
plt.figure(figsize=(5, 5))
plt.pie(total_por_sexo_sem_o['TOTAL'],
        labels=total_por_sexo_sem_o['CS_SEXO'],
        colors=['blue' if sexo == 'MASCULINO' else 'pink' for sexo in total_por_sexo_sem_o['CS_SEXO']],
        autopct=lambda p: '{:.0f} - ({:.1f}%)'.format(p * sum(total_por_sexo_sem_o['TOTAL']) / 100, p),
        startangle=140)

# Adicionando t√≠tulo
plt.title('Distribui√ß√£o de Casos por Sexo')

# Mostrando o gr√°fico
plt.show()

# Filtrando apenas os CASOS CONFIRMADOS sem √≥bito
casos_sem_obito_x = df_Join_03[df_Join_03['OBITO'] == False]

"""Todos os Sexos"""

# Agrupando os dados por CS_SEXO e contando os registros
total_por_sexo = casos_sem_obito_x.groupby('CS_SEXO').size().reset_index(name='Total_Registros_Sexo')

# Calcula o total geral para calcular as porcentagens
total_geral_sexo = total_por_sexo['Total_Registros_Sexo'].sum()

# Ordenando os valores por 'Total_Registros_Sexo' em ordem decrescente
total_por_sexo = total_por_sexo.sort_values(by='Total_Registros_Sexo', ascending=False)

# Criando o gr√°fico de barras com os valores ordenados
plt.figure(figsize=(7, 5))
bars_sexo = plt.bar(total_por_sexo['CS_SEXO'], total_por_sexo['Total_Registros_Sexo'], color='lightblue')
plt.xlabel('Sexo')
plt.ylabel('Total de Registros')
plt.title('Total de Registros por Sexo')

# Adicionando os valores e as porcentagens em cima das barras
for bar in bars_sexo:
    valor = bar.get_height()
    porcentagem = (valor / total_geral_sexo) * 100
    plt.text(
        bar.get_x() + bar.get_width() / 2,
        valor,
        f'{valor} ({porcentagem:.1f}%)',
        ha='center',
        va='bottom'
    )

plt.tight_layout()
plt.show()

"""#### Ra√ßa/Cor"""

# Agrupando os dados por RACA_COR e contando os registros
total_por_raca = casos_sem_obito_x.groupby('RACA_COR').size().reset_index(name='Total_Registros_Raca')

# Calcula o total geral para calcular as porcentagens
total_geral_raca = total_por_raca['Total_Registros_Raca'].sum()

# Ordenando os valores por 'Total_Registros_Raca' em ordem decrescente
total_por_raca = total_por_raca.sort_values(by='Total_Registros_Raca', ascending=False)

# Criando o gr√°fico de barras com os valores ordenados
plt.figure(figsize=(10, 7))
bars_raca = plt.barh(total_por_raca['RACA_COR'], total_por_raca['Total_Registros_Raca'], color='lightgreen')
plt.xlabel('Total de Registros')
plt.ylabel('Ra√ßa/Cor')
plt.title('Total de Registros por Ra√ßa/Cor')

# Adicionando os valores e as porcentagens na frente das barras
for bar in bars_raca:
    valor = bar.get_width()
    porcentagem = (valor / total_geral_raca) * 100
    plt.text(
        valor,
        bar.get_y() + bar.get_height() / 2,
        f'{valor} ({porcentagem:.1f}%)',
        va='center'
    )

plt.tight_layout()
plt.show()

"""#### Idade"""

# Convertendo a coluna 'IDADE' para num√©rico (int), lidando com valores n√£o num√©ricos
casos_sem_obito_x['IDADE'] = pd.to_numeric(casos_sem_obito_x['IDADE'], errors='coerce')

# Definindo as faixas et√°rias
bins = [-1, 0, 4, 9, 19, 29, 39, 49, 59, 69, 79, 89, 999]
labels = ['<1', '1 a 4', '5 a 9', '10 a 19', '20 a 29', '30 a 39', '40 a 49', '50 a 59', '60 a 69', '70 a 79', '80 a 89', '>=90']

# Criando uma nova coluna 'Faixa_Etaria' no DataFrame para as faixas et√°rias
casos_sem_obito_x['Faixa_Etaria'] = pd.cut(casos_sem_obito_x['IDADE'], bins=bins, labels=labels)

# Agrupando os dados por 'Faixa_Etaria' e contando os registros
total_por_faixa_etaria = casos_sem_obito_x.groupby('Faixa_Etaria').size().reset_index(name='Total_Registros_Faixa')

# Calcula o total geral para calcular as porcentagens
total_geral_faixa = total_por_faixa_etaria['Total_Registros_Faixa'].sum()

# Ordenando os valores por 'Total_Registros_Faixa' em ordem crescente
total_por_faixa_etaria = total_por_faixa_etaria.sort_values(by='Total_Registros_Faixa', ascending=True)

# Criando o gr√°fico de barras empilhadas com os valores ordenados
plt.figure(figsize=(12, 8))
bars_faixa = plt.barh(total_por_faixa_etaria['Faixa_Etaria'], total_por_faixa_etaria['Total_Registros_Faixa'], color='lightcoral')

# Adicionando apenas as porcentagens na frente das barras
for bar in bars_faixa:
    valor = bar.get_width()
    porcentagem = (valor / total_geral_faixa) * 100
    plt.text(
        valor,  # Posi√ß√£o X onde o texto ser√° colocado (final da barra)
        bar.get_y() + bar.get_height() / 2,  # Posi√ß√£o Y (centro da barra)
        f'({porcentagem:.1f}%)',  # Formata o texto para incluir apenas a porcentagem
        va='center'  # Alinhamento vertical do texto
    )

plt.xlabel('Porcentagem do Total de Casos')
plt.ylabel('Faixa Et√°ria')
plt.title('Distribui√ß√£o Percentual de Casos por Faixa Et√°ria')

plt.tight_layout()
plt.show()

"""###   An√°lise 2---| Por Munic√≠pio |

Total de casos por Municipio e a porcentagem de cada um em rela√ß√£o aos outros
"""

# Agrupando o df_Join_02 por 'NOME_MUNIC' e somando o total de Casos para cada grupo
total_c_por_mun = df_Join_02.groupby(['NOME_MUNIC'])['CASOS_NOVOS'].sum().reset_index(name='TOTAL')

# Calculando o total de casos
total_casos = total_c_por_mun['TOTAL'].sum()

# Calculando o percentual para cada munic√≠pio
total_c_por_mun['PERCENTUAL'] = (total_c_por_mun['TOTAL'] / total_casos) * 100

# Ordenando os valores do maior para o menor
total_c_por_mun = total_c_por_mun.sort_values(by='TOTAL', ascending=False)

# Formatando os n√∫meros com separadores de milhares e o percentual com duas casas decimais
total_c_por_mun['TOTAL_FORMATADO'] = total_c_por_mun['TOTAL'].apply(lambda x: f"{x:,}")
total_c_por_mun['PERCENTUAL_FORMATADO'] = total_c_por_mun['PERCENTUAL'].apply(lambda x: f"{x:.2f}%")

# Exibindo o resultado com os n√∫meros formatados
display(total_c_por_mun[['NOME_MUNIC', 'TOTAL_FORMATADO', 'PERCENTUAL_FORMATADO']])

"""Total de casos por Municipio e a porcentagem de cada um em rela√ß√£o aos outros - Removendo S√£o Paulo e Campinas"""

# Filtrando para excluir 'S√ÉO PAULO' e 'CAMPINAS' antes de agrupar
df_filtrado = df_Join_02[~df_Join_02['NOME_MUNIC'].isin(['S√ÉO PAULO', 'CAMPINAS'])]

# Agrupando o DataFrame filtrado por 'NOME_MUNIC' e somando o total de Casos para cada grupo
total_c_por_mun2 = df_filtrado.groupby(['NOME_MUNIC'])['CASOS_NOVOS'].sum().reset_index(name='TOTAL')

# Calculando o total de casos ap√≥s a filtragem
total_casos2 = total_c_por_mun2['TOTAL'].sum()

# Calculando o percentual para cada munic√≠pio com base nos munic√≠pios restantes
total_c_por_mun2['PERCENTUAL'] = (total_c_por_mun2['TOTAL'] / total_casos2) * 100

# Ordenando os valores do maior para o menor
total_c_por_mun2 = total_c_por_mun2.sort_values(by='TOTAL', ascending=False)

# Formatando os n√∫meros com separadores de milhares e o percentual com duas casas decimais
total_c_por_mun2['TOTAL_FORMATADO'] = total_c_por_mun2['TOTAL'].apply(lambda x: f"{x:,}")
total_c_por_mun2['PERCENTUAL_FORMATADO'] = total_c_por_mun2['PERCENTUAL'].apply(lambda x: f"{x:.2f}%")

# Exibindo o resultado com os n√∫meros formatados
display(total_c_por_mun2[['NOME_MUNIC', 'TOTAL_FORMATADO', 'PERCENTUAL_FORMATADO']])

# Contando n√∫mero de registros/linhas
num_count_mun_c = df_Join_02.shape[0]

#Formatando resultados
num_count_mun_c_formatado = "{:,}".format(num_count_mun_c).replace(",", ".")
total_casos_formatado = "{:,}".format(total_casos).replace(",", ".")
days_formatado = "{:,}".format(delta.days).replace(",", ".")

print(f"O n√∫mero total de Casos √©: {total_casos_formatado} que ocorreram em {days_formatado} dias, representado aqui com {num_count_mun_c_formatado} linhas/registros na fonte")

"""###   An√°lise 3---| Por GVE|
Inclui-se nesse t√≥pico an√°lises das RA - Regi√µes Administrativas que √© outra forma de vis√£o da divis√£o das regi√µes na SES-SP

Compara√ß√£o de Casos por Regi√£o Administrativa:
"""

# Agrupando os dados por Regi√£o Administrativa e somando os casos e √≥bitos
aggregated_data = df_Join_02.groupby('GVE').agg({'CASOS': 'sum', 'OBITOS': 'sum'}).reset_index()

# Calculando o total de casos
total_casos = aggregated_data['CASOS'].sum()

# Calculando a porcentagem de cada Regi√£o Administrativa
aggregated_data['PERCENTUAL_CASOS'] = (aggregated_data['CASOS'] / total_casos) * 100

# Ordenando os dados pela porcentagem de casos
aggregated_data = aggregated_data.sort_values('PERCENTUAL_CASOS', ascending=False)

# Criando o gr√°fico de cascata para casos
plt.figure(figsize=(15, 5))
waterfall_values = [0] + aggregated_data['PERCENTUAL_CASOS'].tolist()
waterfall_values = np.cumsum(waterfall_values)

# Definindo as barras
for i in range(len(aggregated_data)):
    plt.bar(aggregated_data['GVE'][i], waterfall_values[i+1] - waterfall_values[i], bottom=waterfall_values[i])

# Adicionando linhas para conectar as barras
for i in range(1, len(waterfall_values)):
    plt.plot([i-1.5, i-0.5], [waterfall_values[i], waterfall_values[i]], color='k')

# Adicionando os valores percentuais acima das barras
for i in range(len(aggregated_data)):
    plt.text(i, waterfall_values[i+1], f"{aggregated_data['PERCENTUAL_CASOS'].iloc[i]:.2f}%", ha='center', va='bottom')

# Ajustes finais
plt.xticks(rotation=90)
plt.title('Distribui√ß√£o Percentual de Casos por GVE - Gr√°fico de Cascata')
plt.show()

"""###   An√°lise 4---| Por DRS |

Percentual de Casos por DRS
"""

# CASOS POR DRS com Gradiente de Cor
plt.figure(figsize=(15, 5))  # Ajuste o tamanho conforme necess√°rio

# Agrupando os dados por DRS e calculando a m√©dia de casos
casos_por_drs = df_Join_02.groupby('DRS')['CASOS'].mean().reset_index().sort_values('CASOS', ascending=False)

# Calculando o total de casos para todas as DRS
total_casos_pc = casos_por_drs['CASOS'].sum()

# Calculando o percentual de cada DRS
casos_por_drs['PERCENTUAL'] = (casos_por_drs['CASOS'] / total_casos_pc) * 100

# Obtendo a paleta de cores com base nos valores (quanto maior o valor, mais pr√≥ximo do vermelho)
palette = sns.color_palette("RdYlGn_r", len(casos_por_drs))

# Mapeando a paleta de cores aos valores
bar_plot = sns.barplot(x='DRS', y='PERCENTUAL', data=casos_por_drs, palette=np.array(palette[::-1])[casos_por_drs['PERCENTUAL'].argsort()])

# Adicionando os valores percentuais acima das barras
for index, value in enumerate(casos_por_drs['PERCENTUAL']):
    plt.text(index, value, f'{value:.2f}%', ha='center', va='bottom')

plt.xticks(rotation=90)
plt.title('Percentual de Casos por DRS')
plt.show()

# Agrupando os dados por DRS, SEXO, RACA_COR e IDADE e contando os registros
total_registros_agrupados = casos_sem_obito_x.groupby(['DRS', 'CS_SEXO', 'RACA_COR', 'IDADE']).size().reset_index(name='Total_Registros')

# Calcula o total geral para calcular as porcentagens
total_geral   = total_registros_agrupados['Total_Registros'].sum()
total_por_drs = total_registros_agrupados.groupby('DRS')['Total_Registros'].sum().reset_index()

# Ordenando os valores por 'Total_Registros' em ordem decrescente
total_por_drs = total_por_drs.sort_values(by='Total_Registros', ascending=False)

# Criando o gr√°fico de barras com os valores ordenados
plt.figure(figsize=(10, 7))
bars = plt.barh(total_por_drs['DRS'], total_por_drs['Total_Registros'], color='skyblue')
plt.xlabel('Total de Registros')
plt.ylabel('DRS')
plt.title('Total de Registros por DRS')

# Adicionando os valores e as porcentagens na frente das barras
for bar in bars:
    valor = bar.get_width()
    porcentagem = (valor / total_geral) * 100  # Calcula a porcentagem
    plt.text(
        valor,  # Posi√ß√£o X onde o texto ser√° colocado (final da barra)
        bar.get_y() + bar.get_height() / 2,  # Posi√ß√£o Y (centro da barra)
        f'{valor} ({porcentagem:.1f}%)',  # Formata o texto para incluir valor e porcentagem
        va='center'  # Alinhamento vertical do texto
    )

plt.tight_layout()  # Ajusta automaticamente os par√¢metros da subplot para dar espa√ßo ao redor.

# Exibindo o gr√°fico
plt.show()

"""## üìä√ìBITOS

DataFrame: df_Join_03

###   An√°lise 1---| Linha hist√≥rica |

1-Tend√™ncia de √ìbitos ao Longo do Tempo:
"""

# Certifique-se de que a coluna 'DATAHORA' √© do tipo datetime
df_Join_02['DATAHORA'] = pd.to_datetime(df_Join_02['DATAHORA'])

# Agora, a opera√ß√£o de subtra√ß√£o deve funcionar, pois 'DATAHORA' √© do tipo datetime
df_Join_02['DATAHORA2'] = (df_Join_02['DATAHORA'] - df_Join_02['DATAHORA'].min()).dt.days

plt.figure(figsize=(15, 5))

# Usando a nova coluna 'DATAHORA2' para o eixo X
sns.lineplot(data=df_Join_02, x='DATAHORA2', y='OBITOS_NOVOS', label='√ìbitos Novos')

# Adicionando uma linha de tend√™ncia de regress√£o linear usando 'DATAHORA2'
sns.regplot(data=df_Join_02, x='DATAHORA2', y='OBITOS_NOVOS', scatter=False, color='red', label='Linha de Tend√™ncia')

# Configurando o t√≠tulo e os r√≥tulos
plt.title('Tend√™ncia de √ìbitos Novos ao Longo do Tempo')
plt.xlabel('Dias desde o in√≠cio da pandemia')
plt.ylabel('Quantidade')
plt.legend()
plt.show()

"""Evolu√ß√£o da M√©dia M√≥vel de 7 Dias para √ìbitos

"""

plt.figure(figsize=(15, 5))
sns.lineplot(data=df_Join_02, x='DATAHORA', y='OBITOS_MM7D', label='M√©dia M√≥vel 7 Dias - √ìbitos')
plt.title('Evolu√ß√£o da M√©dia M√≥vel de 7 Dias para √ìbitos')
plt.xlabel('Data')
#plt.ylabel('Quantidade')
#plt.legend()
plt.show()

"""#### Sexo"""

# Filtrando apenas os casos onde OBITO √© True
casos_com_obito = df_Join_03[df_Join_03['OBITO'] == True]

# Agrupando o DataFrame filtrado por 'IDADE' e 'CS_SEXO' e contando os registros
total_registros_por_sexo_e_idade = casos_com_obito.groupby(['IDADE', 'CS_SEXO']).size().reset_index(name='TOTAL')

# Ordenando os resultados pelo 'TOTAL DE REGISTROS' em ordem decrescente
total_registros_por_sexo_e_idade = total_registros_por_sexo_e_idade.sort_values(by='TOTAL', ascending=False)

# Exibindo o resultado
display(total_registros_por_sexo_e_idade)

# Definindo o tamanho da figura
plt.figure(figsize=(20, 10))

# Criando o gr√°fico de barras
plt.bar(total_registros_por_sexo_e_idade['IDADE'].astype(str) ,
        total_registros_por_sexo_e_idade['TOTAL'],
        color=['blue' if sexo == 'MASCULINO' else 'pink' for sexo in total_registros_por_sexo_e_idade['CS_SEXO']])

# Adicionando t√≠tulo e r√≥tulos aos eixos
plt.title('Total de √ìbitos por Sexo e Idade')
plt.xlabel('Grupo de Idade e Sexo')
plt.ylabel('Total de Registros')

# Melhorando a visualiza√ß√£o das etiquetas do eixo x
plt.xticks(rotation=90)

# Mostrando o gr√°fico
plt.show()

# Agregando os dados por sexo e somando os registros
total_por_sexo = total_registros_por_sexo_e_idade.groupby('CS_SEXO')['TOTAL'].sum().reset_index()

# Criando o gr√°fico de pizza
plt.figure(figsize=(5, 5))
plt.pie(total_por_sexo['TOTAL'],
        labels=total_por_sexo['CS_SEXO'],
        colors=['blue' if sexo == 'MASCULINO' else 'pink' for sexo in total_por_sexo['CS_SEXO']],
        autopct=lambda p: '{:n} - ({:.1f}%)'.format(p * sum(total_por_sexo['TOTAL']) / 100, p),
        startangle=140)

# Adicionando t√≠tulo
plt.title('Distribui√ß√£o de √ìbitos por Sexo')

# Mostrando o gr√°fico
plt.show()

# Filtrando apenas os CASOS CONFIRMADOS com √≥bito
casos_com_obito_x = df_Join_03[df_Join_03['OBITO'] == True]

# Agrupando os dados por CS_SEXO e contando os registros
total_por_sexo_o = casos_com_obito_x.groupby('CS_SEXO').size().reset_index(name='Total_Registros_Sexo')

# Calcula o total geral para calcular as porcentagens
total_geral_sexo_o = total_por_sexo_o['Total_Registros_Sexo'].sum()

# Ordenando os valores por 'Total_Registros_Sexo' em ordem decrescente
total_por_sexo_o = total_por_sexo_o.sort_values(by='Total_Registros_Sexo', ascending=False)

# Criando o gr√°fico de barras com os valores ordenados
plt.figure(figsize=(7, 5))
bars_sexo = plt.bar(total_por_sexo_o['CS_SEXO'], total_por_sexo_o['Total_Registros_Sexo'], color='lightblue')
plt.xlabel('Sexo')
plt.ylabel('Total de √ìbitos')
plt.title('Total de √ìbitos por Sexo')

# Adicionando os valores e as porcentagens em cima das barras
for bar in bars_sexo:
    valor = bar.get_height()
    porcentagem = (valor / total_geral_sexo_o) * 100
    plt.text(
        bar.get_x() + bar.get_width() / 2,
        valor,
        f'{valor} ({porcentagem:.1f}%)',
        ha='center',
        va='bottom'
    )

plt.tight_layout()
plt.show()

"""#### Ra√ßa/Cor"""

# Agrupando os dados por RACA_COR e contando os registros
total_por_raca_o = casos_com_obito_x.groupby('RACA_COR').size().reset_index(name='Total_Registros_Raca')

# Calcula o total geral para calcular as porcentagens
total_geral_raca_o = total_por_raca_o['Total_Registros_Raca'].sum()

# Ordenando os valores por 'Total_Registros_Raca' em ordem decrescente
total_por_raca_o = total_por_raca_o.sort_values(by='Total_Registros_Raca', ascending=False)

# Criando o gr√°fico de barras com os valores ordenados
plt.figure(figsize=(10, 7))
bars_raca = plt.barh(total_por_raca_o['RACA_COR'], total_por_raca_o['Total_Registros_Raca'], color='lightgreen')
plt.xlabel('Total de √ìbitos')
plt.ylabel('Ra√ßa/Cor')
plt.title('Total de √ìbitos por Ra√ßa/Cor')

# Adicionando os valores e as porcentagens na frente das barras
for bar in bars_raca:
    valor = bar.get_width()
    porcentagem = (valor / total_geral_raca_o) * 100
    plt.text(
        valor,
        bar.get_y() + bar.get_height() / 2,
        f'{valor} ({porcentagem:.1f}%)',
        va='center'
    )

plt.tight_layout()
plt.show()

"""#### Idade"""

# Convertendo a coluna 'IDADE' para num√©rico (int), lidando com valores n√£o num√©ricos
casos_com_obito_x['IDADE'] = pd.to_numeric(casos_com_obito_x['IDADE'], errors='coerce')

# Criando uma nova coluna 'Faixa_Etaria' no DataFrame para as faixas et√°rias
casos_com_obito_x['Faixa_Etaria'] = pd.cut(casos_com_obito_x['IDADE'], bins=bins, labels=labels)

# Agrupando os dados por 'Faixa_Etaria' e contando os registros
total_por_faixa_etaria_o = casos_com_obito_x.groupby('Faixa_Etaria').size().reset_index(name='Total_Registros_Faixa')

# Calcula o total geral para calcular as porcentagens
total_geral_faixa_o = total_por_faixa_etaria_o['Total_Registros_Faixa'].sum()

# Ordenando os valores por 'Total_Registros_Faixa' em ordem crescente
total_por_faixa_etaria_o = total_por_faixa_etaria_o.sort_values(by='Total_Registros_Faixa', ascending=True)

# Criando o gr√°fico de barras empilhadas com os valores ordenados
plt.figure(figsize=(12, 8))
bars_faixa = plt.barh(total_por_faixa_etaria_o['Faixa_Etaria'], total_por_faixa_etaria_o['Total_Registros_Faixa'], color='lightcoral')

# Adicionando apenas as porcentagens na frente das barras
for bar in bars_faixa:
    valor = bar.get_width()
    porcentagem = (valor / total_geral_faixa_o) * 100
    plt.text(
        valor,  # Posi√ß√£o X onde o texto ser√° colocado (final da barra)
        bar.get_y() + bar.get_height() / 2,  # Posi√ß√£o Y (centro da barra)
        f'({porcentagem:.1f}%)',  # Formata o texto para incluir apenas a porcentagem
        va='center'  # Alinhamento vertical do texto
    )

plt.xlabel('Porcentagem do Total de √ìbitos')
plt.ylabel('Faixa Et√°ria')
plt.title('Distribui√ß√£o Percentual de √ìbitos por Faixa Et√°ria')

plt.tight_layout()
plt.show()

"""###   An√°lise 2---| Por Munic√≠pio |

√ìbitos por Municipio
"""

# Aplicando a condi√ß√£o para substituir valores muito pequenos por zero
df_Join_02['OBITOS'] = df_Join_02['OBITOS'].apply(lambda x: 0 if abs(x) < 1e-10 else x)

plt.figure(figsize=(100, 20))
sns.barplot(x='NOME_MUNIC', y='OBITOS', data=df_Join_02.sort_values('OBITOS', ascending=False))
plt.xticks(rotation=90)
plt.title('√ìbitos em Todos os Munic√≠pios')
plt.show()

"""###   An√°lise 3---| Por GVE|
Inclui-se nesse t√≥pico an√°lises das RA - Regi√µes Administrativas que √© outra forma de vis√£o da divis√£o das regi√µes na SES-SP

Percentual de √ìbitos por 100 mil Habitantes por GVE
"""

# √ìBITOS POR GVE com Gradiente de Cor
plt.figure(figsize=(15, 5))

# Agrupando os dados por GVE e calculando a soma de √≥bitos
obitos_total_por_gve = df_Join_02.groupby('GVE')['OBITOS'].sum().reset_index()

# Calculando o total de √≥bitos
total_obitos = obitos_total_por_gve['OBITOS'].sum()

# Calculando a porcentagem de √≥bitos para cada GVE
obitos_total_por_gve['PERCENTUAL_OBITOS'] = (obitos_total_por_gve['OBITOS'] / total_obitos) * 100

# Ordenando os dados por percentual de √≥bitos em ordem decrescente
obitos_total_por_gve = obitos_total_por_gve.sort_values('PERCENTUAL_OBITOS', ascending=False)

# Obtendo a paleta de cores com base nos valores (quanto maior o valor, mais pr√≥ximo do vermelho)
palette = sns.color_palette("RdYlGn_r", len(obitos_total_por_gve))

# Mapeando a paleta de cores aos valores
bar_plot = sns.barplot(x='GVE', y='PERCENTUAL_OBITOS', data=obitos_total_por_gve, palette=np.array(palette[::-1])[obitos_total_por_gve['PERCENTUAL_OBITOS'].argsort()])

# Adicionando os valores percentuais acima das barras
for index, value in enumerate(obitos_total_por_gve['PERCENTUAL_OBITOS']):
    plt.text(index, value, f'{value:.2f}%', ha='center', va='bottom')

plt.xticks(rotation=90)
plt.title('Percentual de √ìbitos por GVE com Gradiente de Cor')
plt.show()

"""Compara√ß√£o de √ìbitos por Regi√£o Administrativa:"""

# Calculando o total de √≥bitos
total_obitos = aggregated_data['OBITOS'].sum()

# Calculando a porcentagem de cada Regi√£o Administrativa
aggregated_data['PERCENTUAL_OBITOS'] = (aggregated_data['OBITOS'] / total_obitos) * 100

# Ordenando os dados pela porcentagem de casos
aggregated_data2 = aggregated_data.sort_values('PERCENTUAL_OBITOS', ascending=False)

# Criando o gr√°fico de cascata para casos
plt.figure(figsize=(15, 5))
waterfall_values2 = [0] + aggregated_data2['PERCENTUAL_OBITOS'].tolist()
waterfall_values2 = np.cumsum(waterfall_values2)

# Definindo as barras
for i in range(len(aggregated_data2)):
    plt.bar(aggregated_data2['GVE'][i], waterfall_values2[i+1] - waterfall_values2[i], bottom=waterfall_values2[i])

# Adicionando linhas para conectar as barras
for i in range(1, len(waterfall_values2)):
    plt.plot([i-1.5, i-0.5], [waterfall_values2[i], waterfall_values2[i]], color='k')

# Adicionando os valores percentuais acima das barras
for i in range(len(aggregated_data2)):
    plt.text(i, waterfall_values2[i+1], f"{aggregated_data2['PERCENTUAL_OBITOS'].iloc[i]:.2f}%", ha='center', va='bottom')

# Ajustes finais
plt.xticks(rotation=90)
plt.title('Distribui√ß√£o Percentual de √ìbitos por GVE - Gr√°fico de Cascata')
plt.show()

"""###   An√°lise 4---| Por DRS |

Percentual de √ìbitos por 100 mil Habitantes por DRS
"""

# √ìBITOS POR DRS com Gradiente de Cor
plt.figure(figsize=(15, 5))

# Agrupando os dados por DRS e calculando a soma de √≥bitos
obitos_total_por_drs = df_Join_02.groupby('DRS')['OBITOS'].sum().reset_index()

# Calculando o total de √≥bitos
total_obitos = obitos_total_por_drs['OBITOS'].sum()

# Calculando a porcentagem de √≥bitos para cada DRS
obitos_total_por_drs['PERCENTUAL_OBITOS'] = (obitos_total_por_drs['OBITOS'] / total_obitos) * 100

# Ordenando os dados por percentual de √≥bitos em ordem decrescente
obitos_total_por_drs = obitos_total_por_drs.sort_values('PERCENTUAL_OBITOS', ascending=False)

# Obtendo a paleta de cores com base nos valores (quanto maior o valor, mais pr√≥ximo do vermelho)
palette = sns.color_palette("RdYlGn_r", len(obitos_total_por_drs))

# Mapeando a paleta de cores aos valores
bar_plot = sns.barplot(x='DRS', y='PERCENTUAL_OBITOS', data=obitos_total_por_drs, palette=np.array(palette[::-1])[obitos_total_por_drs['PERCENTUAL_OBITOS'].argsort()])

# Adicionando os valores percentuais acima das barras
for index, value in enumerate(obitos_total_por_drs['PERCENTUAL_OBITOS']):
    plt.text(index, value, f'{value:.2f}%', ha='center', va='bottom')

plt.xticks(rotation=90)
plt.title('Percentual de √ìbitos por DRS com Gradiente de Cor')
plt.show()

"""## üìäCASOS x √ìBITOS

###   An√°lise 1---| Linha hist√≥rica |

###   An√°lise 2---| Por Munic√≠pio |

An√°lise de Cluster dos Munic√≠pios Baseada em Casos e √ìbitos:
Este um m√©todo estat√≠stico utilizado para agrupar munic√≠pios que apresentam caracter√≠sticas semelhantes em rela√ß√£o ao n√∫mero de casos e √≥bitos, geralmente em um contexto de doen√ßas ou epidemias, como a COVID-19. O objetivo √© identificar padr√µes ou grupos (clusters) de munic√≠pios com comportamentos similares em termos de incid√™ncia da doen√ßa e mortalidade.

CLUSTER - MODELO 1
"""

from sklearn.cluster import KMeans
X = df_Join_02[['CASOS', 'OBITOS']].dropna()
kmeans = KMeans(n_clusters=4, random_state=0).fit(X)
df_Join_02['CLUSTER'] = kmeans.labels_

sns.scatterplot(data=df_Join_02, x='CASOS', y='OBITOS', hue='CLUSTER', palette='viridis')
plt.title('Clusteriza√ß√£o dos Munic√≠pios Baseada em Casos e √ìbitos')
plt.xlabel('Casos')
plt.ylabel('√ìbitos')
plt.legend(title='Cluster')
plt.show()

"""###   An√°lise 3---| Por GVE|
Inclui-se nesse t√≥pico an√°lises das RA - Regi√µes Administrativas que √© outra forma de vis√£o da divis√£o das regi√µes na SES-SP

###   An√°lise 4---| Por DRS |

Compara√ß√£o do Percentual de Casos e √ìbitos por DRS em Ordem Decrescente
"""

obitos_total_por_drs = df_Join_02.groupby('DRS')['OBITOS'].sum().reset_index()
casos_total_por_drs = df_Join_02.groupby('DRS')['CASOS'].sum().reset_index()

"""Descomente a celula abaixo para remover a DRS da GRANDE SAO PAULO da an√°lise"""

# Removendo a DRS 'GRANDE SAO PAULO'
# casos_total_por_drs = casos_total_por_drs[casos_total_por_drs['DRS'] != 'GRANDE SAO PAULO']
# obitos_total_por_drs = obitos_total_por_drs[obitos_total_por_drs['DRS'] != 'GRANDE SAO PAULO']

# Calculando o total de casos e √≥bitos
total_casos = casos_total_por_drs['CASOS'].sum()
total_obitos = obitos_total_por_drs['OBITOS'].sum()

# Calculando a porcentagem de cada DRS
casos_total_por_drs['PERCENTUAL_CASOS'] = (casos_total_por_drs['CASOS'] / total_casos) * 100
obitos_total_por_drs['PERCENTUAL_OBITOS'] = (obitos_total_por_drs['OBITOS'] / total_obitos) * 100

# Ordenando os DataFrames em ordem decrescente de percentual
casos_total_por_drs = casos_total_por_drs.sort_values('PERCENTUAL_CASOS', ascending=False)
obitos_total_por_drs = obitos_total_por_drs.sort_values('PERCENTUAL_OBITOS', ascending=False)

# Criando o gr√°fico de barras horizontais
plt.figure(figsize=(10, 10))

# Largura das barras
barHeight = 0.4

# Definindo a posi√ß√£o das barras
r1 = range(len(casos_total_por_drs))
r2 = [x + barHeight for x in r1]

# Plotando as barras de casos
plt.barh(r1, casos_total_por_drs['PERCENTUAL_CASOS'], color='blue', height=barHeight, edgecolor='grey', label='Casos (%)')
# Plotando as barras de √≥bitos
plt.barh(r2, obitos_total_por_drs['PERCENTUAL_OBITOS'], color='red', height=barHeight, edgecolor='grey', label='√ìbitos (%)')

# Adicionando os valores ao lado das barras
for i in range(len(r1)):
    plt.text(casos_total_por_drs['PERCENTUAL_CASOS'].iloc[i], r1[i], f"{casos_total_por_drs['PERCENTUAL_CASOS'].iloc[i]:.2f}%", va='center')
    plt.text(obitos_total_por_drs['PERCENTUAL_OBITOS'].iloc[i], r2[i], f"{obitos_total_por_drs['PERCENTUAL_OBITOS'].iloc[i]:.2f}%", va='center')

# Adicionando legendas √†s barras
plt.ylabel('DRS', fontweight='bold')
plt.yticks([r + barHeight for r in range(len(casos_total_por_drs))], casos_total_por_drs['DRS'])

# Invertendo o eixo y para que os maiores valores apare√ßam no topo
plt.gca().invert_yaxis()

# Criando a legenda e mostrando o gr√°fico
plt.legend()
plt.title('Compara√ß√£o do Percentual de Casos e √ìbitos por DRS em Ordem Decrescente')
plt.show()

"""Percentual de √ìbitos e Total de Casos por DRS"""

plt.figure(figsize=(15, 5))

# Cria o gr√°fico de barras para os √≥bitos
bar_plot = sns.barplot(x='DRS', y='PERCENTUAL_OBITOS', data=obitos_total_por_drs, palette=np.array(palette[::-1])[obitos_total_por_drs['PERCENTUAL_OBITOS'].argsort()])

# Adiciona os valores percentuais acima das barras
for index, value in enumerate(obitos_total_por_drs['PERCENTUAL_OBITOS']):
    plt.text(index, value, f'{value:.2f}%', ha='center', va='bottom')

# Ajusta a rota√ß√£o dos ticks no eixo X
plt.xticks(rotation=90)

# Adiciona t√≠tulo e legenda para √≥bitos
plt.title('Percentual de √ìbitos e Total de Casos por DRS')
plt.legend(title='√ìbitos', loc='upper left')

# Adiciona a grade apenas no eixo prim√°rio (√≥bitos)
bar_plot.grid(True)

# Cria um eixo secund√°rio para o gr√°fico de linha
ax2 = plt.twinx()

# Plota o gr√°fico de linha para os casos totais no eixo secund√°rio
sns.lineplot(x='DRS', y='CASOS', data=casos_total_por_drs, sort=False, marker='o', color='blue', ax=ax2)

# Remove as linhas de grade do eixo secund√°rio (casos)
ax2.grid(False)

# Remove a legenda do gr√°fico de linha (casos)
ax2.legend([],[], frameon=False)

plt.show()

"""## üåçMAPAS

### CASOS

#### Prepara√ß√£o dos dados
"""

# Verificando se h√° registros nulos
print(df_Join_03['LAT_'].isnull().sum())
print(df_Join_03['LON_'].isnull().sum())

# Removendo registros onde 'LATITUDE' ou 'LONGITUDE' s√£o 0, NaN ou null
df_Join_03 = df_Join_03[(df_Join_03['LAT_'] != 0) & (df_Join_03['LON_'] != 0)]
df_Join_03.dropna(subset=['LAT_', 'LON_'], inplace=True)

num_linhas9 = df_Join_03.shape[0]
num_linhas10 = num_linhas8 - num_linhas9
print(f"O n√∫mero de linhas no df_Join_03 √©: {num_linhas9} sendo que  {num_linhas10} registros foram exclu√≠dos")

# Validar se o tratamento foi bem-sucedido
print(df_Join_03['LAT_'].isnull().sum())   # Deve ser 0
print(df_Join_03['LON_'].isnull().sum())  # Deve ser 0

"""##### 1-Marca√ß√£o dos Munic√≠pios mais cr√≠ticos - com exce√ß√£o de 'S√ÉO PAULO'

Selecionando uma amostragem de 0,50% dos dados
e removendo S√ÉO PAULO que sozinha representa 17% do total.
"""

# Filtrando para excluir 'S√ÉO PAULO'
df_Join_03_filtrado = df_Join_03[df_Join_03['NOME_MUNIC'] != 'S√ÉO PAULO']

# Criando uma amostra de X.00% do DataFrame filtrado
df_Join_03_amostragem = df_Join_03_filtrado.sample(frac=0.05)

# Contando o total de registros/linhas
count_1 = df_Join_03.shape[0]
count_2 = df_Join_03_amostragem.shape[0]

#Formatando resultados
count_1_F = "{:,}".format(count_1).replace(",", ".")
count_2_F = "{:,}".format(count_2).replace(",", ".")


print(f"O n√∫mero de linhas do JOIN_03 antes da amostragem √©: {count_1_F} com a amostragem temos {count_2_F} para trabalhar com os mapa")

# Analisando total de registros por Municipio ANTES da amostragem
df_Join_03.NOME_MUNIC.value_counts()

# Analisando total de registros por Municipio DEPOIS da amostragem
df_Join_03_amostragem.NOME_MUNIC.value_counts()

# Aqui √© poss√≠vel visualizar o total de municipios em (Length) que est√£o entrando na an√°lise, sabendo que s√£o 645 munic√≠pios no Estado de S√£o Paulo

"""##### ‚òëÔ∏èRESUL_1"""

# Fun√ß√£o para determinar a cor do marcador com base na porcentagem
def get_marker_color(percentage):
    if percentage >= 10:
        return 'darkred'
    elif percentage >= 2:
        return 'red'
    elif percentage >= 1.5:
        return 'orange'
    elif percentage >= 1.3:
        return 'darkblue'
    elif percentage >= 1:
        return 'blue'
    elif percentage >= 0.05:
        return 'yellow'
    else:
        return 'black'  # Para porcentagens abaixo de 0,50%

# Criando uma nova figura de mapa
plt.figure(figsize=(25, 25))

# Inicializando um mapa com a proje√ß√£o 'merc' centrada em S√£o Paulo
m = Basemap(projection='merc',
            llcrnrlat=-25.0,  # latitude do canto inferior esquerdo
            urcrnrlat=-20.0,  # latitude do canto superior direito
            llcrnrlon=-53.0,  # longitude do canto inferior esquerdo
            urcrnrlon=-44.0,  # longitude do canto superior direito
            lat_ts=20,        # latitude de "true scale"
            resolution='i')   # resolu√ß√£o 'i' para intermedi√°ria

# Desenhando a costa, estados e pa√≠ses
m.drawcoastlines()
m.drawstates()
m.drawcountries()

# Contando as ocorr√™ncias de cada munic√≠pio no DataFrame
municipios_contagem = df_Join_03_amostragem['NOME_MUNIC'].value_counts().to_dict()
total_registros = sum(municipios_contagem.values())

# Iterando sobre o dataframe para adicionar os marcadores
for index, row in df_Join_03_amostragem.iterrows():
    municipio = row['NOME_MUNIC']
    contagem = municipios_contagem[municipio]
    porcentagem = (contagem / total_registros) * 100

    # Verificando se a contagem √© maior que 0.05% do total de registros
    if porcentagem >= 0.80: # para aumentar ou diminuir a porcentagem basta alterar o valor de 0 'zero'
        # Separando latitude e longitude
        lat, lon = map(float, row['LAT_LON'].split(','))  # Dividindo a string em latitude e longitude

        # Convertendo as coordenadas para o sistema de proje√ß√£o do mapa
        x, y = m(lon, lat)

        # Escolhendo a cor do marcador
        marker_color = get_marker_color(porcentagem)

        # Adicionando um marcador no mapa para cada munic√≠pio
        m.plot(x, y, 'o', markersize=15, color=marker_color)

        # Vers√£o visualizando no marcador do mapa: Municipio, Total de registro  Porcentagem
        #plt.text(x, y, f"{municipio} \n({total_registros} - {porcentagem:.2f}%)", fontsize=8, ha='center', va='bottom')

        # Vers√£o visualizando no marcador do mapa: Municipio e a porcentagem em rela√ß√£o aos outros munic√≠pios
        plt.text(x, y, f"{municipio} \n({porcentagem:.2f}%)", fontsize=9, ha='center', va='bottom')

# Mostrando o resultado
plt.show()

"""##### 2-Mapa de calor dos casos confirmados da AMOSTRAGEM"""

# Criando um mapa centrado em torno das coordenadas de S√£o Paulo
mapa1 = folium.Map(location=coordenadas_centro_sp, zoom_start=7, control_scale=True, tiles="cartodbpositron")

# Preparando os dados para o mapa de calor
heat_data = [
    [float(coord) for coord in row['LAT_LON'].split(',')] + [municipios_contagem[row['NOME_MUNIC']]]
    for _, row in df_Join_03_amostragem.iterrows()
]

# Adicionando o mapa de calor ao mapa
HeatMap(heat_data).add_to(mapa1)

"""##### ‚òëÔ∏èRESUL_2"""

# Exibindo o mapa
mapa1

import seaborn as sns
import matplotlib.pyplot as plt

# Configurando o estilo do gr√°fico
sns.set_style('darkgrid')

# Carregando o dataframe
df_casos = df_Join_02

# Criando o histograma com distplot
sns.distplot(df_casos['DATAHORA'], rug=True, rug_kws={"color": "red"}, kde=False, color="green")

# Adicionando t√≠tulos e r√≥tulos
plt.title('Distribui√ß√£o de Idade dos Casos')
plt.xlabel('Idade')
plt.ylabel('Frequ√™ncia')

# Mostrando o gr√°fico
plt.show()

# Agrupando os dados por idade e contando o n√∫mero de casos
casos_por_idade = df_Join_03.groupby('IDADE').size().reset_index(name='Numero_de_Casos')

# Ordenando os resultados pela idade
casos_por_idade.sort_values('IDADE', inplace=True)

# Configurando o tamanho da figura
plt.figure(figsize=(15,5))

# Plotando o gr√°fico de barras
sns.barplot(x='IDADE', y='Numero_de_Casos', data=casos_por_idade)

# Adicionando r√≥tulos e t√≠tulo
plt.ylabel('N√∫mero de Casos')
plt.xlabel('Idade')
plt.title('N√∫mero de Casos por Grupo de Idade')

# Mostrando o gr√°fico
plt.show()

"""### √ìBITOS

##### 1- √ìbitos por Munic√≠pio no Estado de S√£o Paulo
"""

# Agrupando os dados por munic√≠pio e somando os √≥bitos
obitos_por_municipio = df_Join_02.groupby('CODIGO_IBGE')['OBITOS'].sum().reset_index()

# Convertendo o c√≥digo do munic√≠pio para o mesmo tipo de dado do GeoDataFrame para garantir a compatibilidade no merge
obitos_por_municipio['CODIGO_IBGE'] = obitos_por_municipio['CODIGO_IBGE'].astype(float)

# Mesclando os dados de √≥bitos com o GeoDataFrame dos munic√≠pios
gdf_mun1 = gdf_mun1.merge(obitos_por_municipio, left_on='code_muni', right_on='CODIGO_IBGE')

# Plotando o mapa com os dados de √≥bitos
fig, ax = plt.subplots(figsize=(10, 10))
gdf_mun1.plot(ax=ax, column='OBITOS', cmap='OrRd', legend=True,
             legend_kwds={'label': "Total de √ìbitos por Munic√≠pio",
                          'orientation': "horizontal"})
plt.title('√ìbitos por Munic√≠pio no Estado de S√£o Paulo')
plt.show()

"""√ìbitos por Munic√≠pio no Estado de SP - Removendo o Munic√≠pio de S√£o Paulo da an√°lise"""

# Filtrando para remover o munic√≠pio de S√£o Paulo
df_Join_02_filtered = df_Join_02[df_Join_02['CODIGO_IBGE'] != 3550308]

# Agrupando os dados por munic√≠pio e somando os √≥bitos
obitos_por_municipio = df_Join_02_filtered.groupby('CODIGO_IBGE')['OBITOS'].sum().reset_index()

# Convertendo o c√≥digo do munic√≠pio para o mesmo tipo de dado do GeoDataFrame para garantir a compatibilidade no merge
obitos_por_municipio['CODIGO_IBGE'] = obitos_por_municipio['CODIGO_IBGE'].astype(float)

# Mesclando os dados de √≥bitos com o GeoDataFrame dos munic√≠pios
gdf_mun_filtered = gdf_mun2[gdf_mun2['code_muni'] != 3550308]  # Removendo S√£o Paulo do GeoDataFrame tamb√©m
gdf_mun_filtered = gdf_mun_filtered.merge(obitos_por_municipio, left_on='code_muni', right_on='CODIGO_IBGE')

# Plotando o mapa com os dados de √≥bitos
fig, ax = plt.subplots(figsize=(10, 10))
gdf_mun_filtered.plot(ax=ax, column='OBITOS', cmap='OrRd', legend=True,
                      legend_kwds={'orientation': "horizontal"})
plt.title('√ìbitos por Munic√≠pio no Estado de S√£o Paulo (sem SP)')
plt.show()

"""##### 2-Marca√ß√£o dos Munic√≠pios mais cr√≠ticos - com exce√ß√£o de 'S√ÉO PAULO'"""

# Filtrando para excluir 'S√ÉO PAULO'
df_Join_03_filter1 = df_Join_03[df_Join_03['OBITO'] == True]

# Filtrando para excluir 'S√ÉO PAULO'
df_Join_03_filter2 = df_Join_03_filter1[df_Join_03_filter1['NOME_MUNIC'] != 'S√ÉO PAULO']

# Criando uma amostra de X.00% do DataFrame filtrado
#df_Join_03_filter3 = df_Join_03_filter2.sample(frac=0.05)

# Contando o total de registros/linhas
count_1_o = df_Join_03_filter1.shape[0]
count_2_o = df_Join_03_filter2.shape[0]

#Formatando resultados
count_1_o_F = "{:,}".format(count_1_o).replace(",", ".")
count_2_o_F = "{:,}".format(count_2_o).replace(",", ".")


print(f"O n√∫mero de linhas do JOIN_03 j√° filtrado s√≥ √≥bitos √©: {count_1_o_F} removendo o munic√≠pio de 'S√ÉO PAULO' temos {count_2_o_F} para trabalhar com os mapa")

"""##### ‚òëÔ∏èRESUL_1"""

# Fun√ß√£o para determinar a cor do marcador com base na porcentagem
def get_marker_color_obito(percentage):
    if percentage >= 10:
        return 'darkred'
    elif percentage >= 2:
        return 'red'
    elif percentage >= 1.5:
        return 'orange'
    elif percentage >= 1.3:
        return 'darkblue'
    elif percentage >= 1:
        return 'blue'
    elif percentage >= 0.05:
        return 'yellow'
    else:
        return 'black'  # Para porcentagens abaixo de 0,50%



# Criando uma nova figura de mapa
plt.figure(figsize=(25, 25))

# Inicializando um mapa com a proje√ß√£o 'merc' centrada em S√£o Paulo
m = Basemap(projection='merc',
            llcrnrlat=-25.0,  # latitude do canto inferior esquerdo
            urcrnrlat=-20.0,  # latitude do canto superior direito
            llcrnrlon=-53.0,  # longitude do canto inferior esquerdo
            urcrnrlon=-44.0,  # longitude do canto superior direito
            lat_ts=20,        # latitude de "true scale"
            resolution='i')   # resolu√ß√£o 'i' para intermedi√°ria

# Desenhando a costa, estados e pa√≠ses
m.drawcoastlines()
m.drawstates()
m.drawcountries()

# Contando as ocorr√™ncias de cada munic√≠pio no DataFrame
municipios_contagem_obito = df_Join_03_filter2['NOME_MUNIC'].value_counts().to_dict()
total_registros_o = sum(municipios_contagem_obito.values())

# Iterando sobre o dataframe para adicionar os marcadores
for index, row in df_Join_03_filter2.iterrows():
    municipio = row['NOME_MUNIC']
    contagem = municipios_contagem_obito[municipio]
    porcentagem = (contagem / total_registros_o) * 100

    # Verificando se a contagem √© maior que 0.05% do total de registros
    if porcentagem >= 0.80: # para aumentar ou diminuir a porcentagem basta alterar o valor de 0 'zero'
        # Separando latitude e longitude
        lat, lon = map(float, row['LAT_LON'].split(','))  # Dividindo a string em latitude e longitude

        # Convertendo as coordenadas para o sistema de proje√ß√£o do mapa
        x, y = m(lon, lat)

        # Escolhendo a cor do marcador
        marker_color = get_marker_color_obito(porcentagem)

        # Adicionando um marcador no mapa para cada munic√≠pio
        m.plot(x, y, 'o', markersize=15, color=marker_color)

        # Vers√£o visualizando no marcador do mapa: Municipio, Total de registro  Porcentagem
        #plt.text(x, y, f"{municipio} \n({total_registros_o} - {porcentagem:.2f}%)", fontsize=8, ha='center', va='bottom')

        # Vers√£o visualizando no marcador do mapa: Municipio e a porcentagem em rela√ß√£o aos outros munic√≠pios
        plt.text(x, y, f"{municipio} \n({porcentagem:.2f}%)", fontsize=9, ha='center', va='bottom')

# Mostrando o resultado
plt.show()

"""##### 3-Mapa de calor dos √≥bitos"""

# Criando um mapa centrado em torno das coordenadas de S√£o Paulo
mapa2 = folium.Map(location=coordenadas_centro_sp, zoom_start=7, control_scale=True, tiles="cartodbpositron")

# Preparando os dados para o mapa de calor
heat_data = [
    [float(coord) for coord in row['LAT_LON'].split(',')] + [municipios_contagem_obito[row['NOME_MUNIC']]]
    for _, row in df_Join_03_filter2.iterrows()
]

# Adicionando o mapa de calor ao mapa
HeatMap(heat_data).add_to(mapa2)

"""##### ‚òëÔ∏èRESUL_2"""

# Exibindo o mapa
mapa2

"""# üìç4.Modelos de Machine Learning

1.   CASOS: df_Join_02
2.   OBITOS:df_Join_03

## ‚ñ∂Ô∏èFEATURES x LABELS

Features (Vari√°veis Independentes)


*   **NOME_MUNIC**: Pode ser transformado em uma vari√°vel categ√≥rica num√©rica usando t√©cnicas como one-hot encoding ou label encoding.
*  **CODIGO_IBGE**: Identificador √∫nico para cada munic√≠pio, pode ser usado como uma feature categ√≥rica.
*  **DIA e MES:** Indicadores temporais que podem ser √∫teis para capturar sazonalidade.
* **DATAHORA:** Pode ser decomposta em componentes como ano, m√™s, dia da semana, etc.
* **CASOS_NOVOS, CASOS_PC** (casos por 100k habitantes), **CASOS_MM7D** (m√©dia m√≥vel de 7 dias): Indicadores da evolu√ß√£o da pandemia.
* **OBITOS_NOVOS, OBITOS_PC** (√≥bitos por 100k habitantes), **OBITOS_MM7D** (m√©dia m√≥vel de 7 dias): Outros indicadores da evolu√ß√£o da pandemia.
* **POP**, **POP_60**: Popula√ß√£o total e popula√ß√£o acima de 60 anos, que podem ser indicadores de risco.
* **AREA**: √Årea do munic√≠pio, que pode ser relacionada √† densidade populacional.
* **LATITUDE**, **LONGITUDE**, **LAT_LON**: Coordenadas geogr√°ficas que podem ser usadas para modelar aspectos espaciais.
* **SEMANA_EPIDEM**, **ANO**: Indicadores temporais adicionais.
* **CLUSTER**: Se houver uma pr√©via clusteriza√ß√£o dos dados, pode ser uma feature relevante.

Labels (Vari√°veis Dependentes ou Alvo)

* **CASOS e CASOS_NOVOS**: N√∫mero total de casos e novos casos de COVID-19, j√° que o objetivo √© prever a evolu√ß√£o da pandemia.

* **OBITOS e OBITOS_NOVOS**: N√∫mero total de √≥bitos ou novos √≥bitos, j√° que o foco √© prever a mortalidade.

## ‚ñ∂Ô∏èPREPARAR DADOS DE CASOS DE COVID PARA TREINAMENTOS E TESTES
Pr√©-processamento

### Intervalos
**Conjunto de treinamento (Training set)**: Este √© o conjunto de dados usado para treinar o modelo. O modelo aprende a fazer previs√µes com este conjunto de dados.

**Conjunto de teste (Test set)**: Ap√≥s o treinamento, voc√™ testa o modelo com este conjunto de dados. √â importante que o modelo nunca tenha visto os dados de teste durante o treinamento. Isso fornece uma avalia√ß√£o mais honesta do desempenho do modelo em dados n√£o vistos.

**Conjunto de valida√ß√£o (Validation set)**: Em alguns casos, especialmente quando voc√™ est√° ajustando hiperpar√¢metros ou fazendo sele√ß√£o de modelos, voc√™ pode querer ter um terceiro conjunto de dados chamado conjunto de valida√ß√£o. Este conjunto √© usado para fazer ajustes no modelo sem tocar no conjunto de teste, que √© reservado para a avalia√ß√£o final.
"""

# Per√≠odo de treinamento
df_train_start = '2020-01-01'
df_train_end = '2022-12-31'

# Per√≠odo de teste
df_test_start = '2023-01-01'
df_test_end = '2023-06-30'

# Per√≠odo de previs√£o
df_prev_start = '2023-07-01'
df_prev_end = '2023-12-31'

"""Convers√£o de tipos de dados:"""

# Convertendo 'DATAHORA' para datetime
df_Join_02['DATAHORA'] = pd.to_datetime(df_Join_02['DATAHORA'])

# Convertendo 'LATITUDE' e 'LONGITUDE' para float
df_Join_02['LAT_'] = df_Join_02['LAT_'].astype(float)
df_Join_02['LON_'] = df_Join_02['LON_'].astype(float)

"""### Tratamento de valores ausentes
Preencher ou excluir linhas com valores ausentes
"""

# Contando o total de registros (ANTES)
count_1_MM = df_Join_02.shape[0]

#Formatando resultados
count_1_MM_F = "{:,}".format(count_1_MM).replace(",", ".")


print(f"O n√∫mero de linhas do JOIN_02 antes da exclus√£o √©: {count_1_MM_F} ")

# Verificando valores ausentes
#print(df_Join_02.isnull().sum())

# Tratamento de valores ausentes (exemplo: preenchendo com a m√©dia ou removendo)
df_Join_02['CASOS_NOVOS'] = df_Join_02['CASOS_NOVOS'].fillna(df_Join_02['CASOS_NOVOS'].mean())

"""### Engenharia de Features"""

# Agregando os casos por dia para todo o estado
df_aggregated = df_Join_02.groupby('DATAHORA')['CASOS_NOVOS'].sum().reset_index()

"""Sele√ß√£o de Features"""

# Selecionando a s√©rie temporal de interesse
y = df_aggregated.set_index('DATAHORA')['CASOS_NOVOS']

"""### Evitar Data Leakage"""

# Garantindo que o conjunto de teste n√£o contenha informa√ß√µes do conjunto de treinamento
train = y[(y.index >= df_train_start) & (y.index <= df_train_end)]
test = y[(y.index >= df_test_start) & (y.index <= df_test_end)]

"""Preparando DatFrame para Testar os modelos preditivos"""

dfTEST = df_aggregated

# criando um √≠ndice de data
dfTEST.index = pd.to_datetime(dfTEST.DATAHORA, infer_datetime_format=True)
dfTEST.drop("DATAHORA", 1, inplace=True)

# selecionando apenas coluna de "Total Confirmados"
dfTEST = dfTEST[["CASOS_NOVOS"]]

# renomeando a coluna para "total"
dfTEST.columns = ["total"]

# visualiando as 5 primeiras linhas do conjunto de dados
dfTEST.head()

"""Explorando os dados"""

fig, ax = plt.subplots(figsize=(13,5))
ax.scatter(
    dfTEST["total"].index,
    dfTEST["total"].values,
    color="blue"
)
plt.title('Explorando os dados de Casos de COVID-19')
plt.show()

"""## ‚ñ∂Ô∏èTIPOS DE MODELOS

### 1- Auto-Arima (v.1)
Usar a biblioteca pmdarima para ajustar um modelo AUTO-ARIMA.
O AUTO-ARIMA √© um modelo univariado, o que significa que ele leva em considera√ß√£o apenas uma vari√°vel de tempo (y) para fazer as previs√µes. Portanto, vamos preparar a s√©rie temporal de casos novos para treinamento.
"""

# Ajustando o modelo AUTO-ARIMA
auto_arima_model = pm.auto_arima(train, seasonal=True, m=7, suppress_warnings=True, stepwise=True, error_action='ignore')

# Fazendo previs√µes para o conjunto de teste
predictions = auto_arima_model.predict(n_periods=len(test))

# Avaliando o modelo
from sklearn.metrics import mean_squared_error
mse = mean_squared_error(test, predictions)
print(f'Test MSE: {mse}')

"""O Mean Squared Error (MSE) √© uma m√©trica usada para avaliar a qualidade de um modelo de previs√£o. Ele mede a m√©dia dos quadrados dos erros, ou seja, a m√©dia das diferen√ßas ao quadrado entre os valores previstos pelo modelo e os valores reais.

A f√≥rmula para calcular o MSE √©:

![image.png](data:image/png;base64,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)


No nosso caso, um MSE de 16.091.389 sugere que, em m√©dia, o quadrado do erro na previs√£o de novos casos de COVID-19 com este modelo preditivo √© consideravelmente grande. Isso indica que as previs√µes do modelo AUTO-ARIMA est√£o bastante distantes dos valores reais.
"""

# Criando o √≠ndice de data/hora para as previs√µes futuras
future_index = pd.date_range(start=df_test_end, periods=len(predictions), freq='D')

# Plotando os resultados
plt.figure(figsize=(15, 5))
plt.plot(train.index, train, label='Dados de Treino')
plt.plot(test.index, test, label='Dados de Teste')
plt.plot(future_index, predictions, label='Previs√µes', color='red')
plt.title('Previs√£o com ARIMA v.1: Treinamento, Teste e Previs√£o Futura')
plt.xlabel('Data')
plt.ylabel('N√∫mero de Casos Novos')
plt.legend()
plt.show()

# Calculando o n√∫mero de per√≠odos para previs√µes futuras
future_periods = (pd.to_datetime(df_prev_end) - pd.to_datetime(df_test_end)).days

# Fazendo previs√µes futuras
future_forecast = auto_arima_model.predict(n_periods=future_periods)

# Criando o √≠ndice de data/hora para as previs√µes futuras
future_index = pd.date_range(start=df_test_end, periods=future_periods, freq='D')

# Plotando as previs√µes futuras
plt.figure(figsize=(15, 5))
plt.plot(train.index, train, label='Dados de Treino')
plt.plot(test.index, test, label='Dados de Teste')
plt.plot(future_index, future_forecast, label='Previs√£o Futura', color='green')
plt.title('Previs√£o com ARIMA v.1: Treinamento, Teste e Previs√£o Futura')
plt.xlabel('Data')
plt.ylabel('N√∫mero de Casos Novos')
plt.legend()
plt.show()

"""### 1- Auto-Arima (v.2)"""

# Criando uma amostra de X.00% do DataFrame filtrado
#dfTEST_amostra = dfTEST.sample(frac=0.10)
dfTEST_amostra = dfTEST

import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.arima.model import ARIMA
from sklearn.metrics import mean_squared_error

# Supondo que dfTEST_amostra j√° esteja definido e que 'DATAHORA' seja o √≠ndice em formato datetime
dfTEST_amostra.index = pd.to_datetime(dfTEST_amostra.index)

# Definindo os per√≠odos de treinamento e teste
df_train_start = '2020-01-01'  # Data de in√≠cio do treinamento
df_train_end = '2022-12-31'    # Data de fim do treinamento
df_test_start = '2023-01-01'   # Data de in√≠cio do teste
df_test_end = '2023-06-30'     # Data de fim do teste

# Per√≠odo de previs√£o
df_prev_start = '2023-07-01'   # Data de in√≠cio da previs√£o
df_prev_end = '2023-12-31'     # Data de fim da previs√£o

# Segmentando os dados de acordo com os per√≠odos de treinamento e teste
train_data = dfTEST_amostra.loc[df_train_start:df_train_end, 'total']
test_data = dfTEST_amostra.loc[df_test_start:df_test_end, 'total']

# Criando e treinando o modelo ARIMA
model_arima = ARIMA(train_data, order=(5,1,0))  # A ordem (p,d,q) pode precisar de ajustes
model_arima_fit = model_arima.fit()

# Previs√µes para o per√≠odo de teste
test_predictions = model_arima_fit.forecast(steps=len(test_data))
test_predictions.index = test_data.index  # Ajustando os √≠ndices para corresponder aos dados de teste

# Previs√µes para o per√≠odo futuro
n_future_steps = (pd.to_datetime(df_prev_end) - pd.to_datetime(df_prev_start)).days + 1
future_predictions = model_arima_fit.forecast(steps=n_future_steps)
future_dates = pd.date_range(start=df_prev_start, end=df_prev_end)
future_predictions.index = future_dates  # Ajustando os √≠ndices para o per√≠odo futuro

# Plotando os resultados
plt.figure(figsize=(14, 7))

# Dados de treinamento
plt.plot(train_data.index, train_data, 'b-', label='Dados de Treino')

# Dados de teste
plt.plot(test_data.index, test_data, 'r-', label='Dados de Teste')

# Previs√µes para o per√≠odo de teste
plt.plot(test_predictions.index, test_predictions, 'g--', label='Previs√µes do ARIMA para Teste')

# Previs√µes para o per√≠odo futuro
plt.plot(future_predictions.index, future_predictions, 'y--', label='Previs√µes Futuras do ARIMA')

plt.title('Previs√£o com ARIMA v.2: Treinamento, Teste e Previs√£o Futura')
plt.xlabel('Data')
plt.ylabel('Total de Casos')
plt.legend()
plt.show()

"""Conclus√£o: Modelo n√£o atende, possivelmente por ter dados N√£o Estacion√°rios: O ARIMA funciona melhor com dados estacion√°rios. Neste caso os dados originais cont√™m tend√™ncias e sazonalidades fortes que propocitalmente n√£o foram adequadas.

### <h2>2- Modelagem usando a curva exponencial</h2>
"""

from scipy import optimize
import numpy as np
import matplotlib.pyplot as plt

def exp_func(X, a, b, c):
    y = a + b**(X-c)
    return y

# Fornecendo um palpite inicial para os par√¢metros
initial_guess = [1, 1, 1]  # Este √© apenas um exemplo. Ajuste conforme necess√°rio.

# Otimiza√ß√£o com valores iniciais e maxfev aumentado
popt, pcov = optimize.curve_fit(exp_func, np.arange(len(dfTEST["total"])), dfTEST["total"].values, p0=initial_guess, maxfev=5000)

# Gr√°fico
plt.figure(figsize=(15, 6))
plt.plot(np.arange(len(dfTEST["total"])), exp_func(np.arange(len(dfTEST["total"])), *popt), 'g--',
         label='fit: a=%5.3f, b=%5.3f, c=%5.3f' % tuple(popt))
plt.plot(np.arange(len(dfTEST["total"])), dfTEST["total"].values)
plt.title('Previs√£o com Curva Exponencial: Treinamento, Teste e Previs√£o Futura')
plt.xlabel('x')
plt.ylabel('y')
plt.legend()
plt.show()

# criando fun√ß√£o pra converter data em dias
def data_to_days(date):
    x = (date - dfTEST_amostra.index[-1]).days + len(dfTEST_amostra['total'])
    return x

# criando o modelo usando os par√¢metros ajustados
def exp_model(X):
    X = data_to_days(X)
    y = -9.395 + np.exp(0.0055 * (X - 52.146))  # Ajuste o valor 0.044 conforme necess√°rio np.exp(0.0000 * ....)
    return int(y)

tomorrow = datetime.today() + timedelta(days=1)
after_tomorrow = datetime.today() + timedelta(days=120)

print("Amanh√£:", exp_model(tomorrow))
print("em 120 dias:", exp_model(after_tomorrow))

#Coeficiente de Crescimento: A constante multiplicativa do X na fun√ß√£o exponencial acima (0.000008) controla a taxa de crescimento. Reduzir esse valor far√° com que o n√∫mero de casos aumente mais lentamente.
#Offset: O valor -9.395 determina onde a curva come√ßa no eixo y. Para alterar o ponto de partida da curva √© este o valor a ser ajustado.

#CONCLUS√ÉO: Este modelo se aproxima da m√©dia de casos di√°rios existentes hoje

"""### <h2>3- Modelagem usando a curva gaussiana</h2>"""

# func√£o gaussiana com par√¢metros a, b e c
def gaussian_func(X, a, b, c):
    y = a * np.exp( -(X-b)**2 / (2*c**2) )
    return y

# otimiza√ß√£o usando scipy
popt, pcov = optimize.curve_fit(gaussian_func, np.arange(len(dfTEST_amostra["total"])), dfTEST_amostra["total"].values)

# gr√°fico
plt.figure(figsize=(15, 6))
plt.plot(np.arange(len(dfTEST_amostra["total"])), gaussian_func(np.arange(len(dfTEST_amostra["total"])), *popt), 'g--',
         label='fit: a=%5.3f, b=%5.3f, c=%5.3f' % tuple(popt))
plt.plot(np.arange(len(dfTEST_amostra["total"])), dfTEST_amostra["total"].values)
plt.title('Previs√£o com Curva Gaussiana: Treinamento, Teste e Previs√£o Futura')
plt.xlabel('x')
plt.ylabel('y')
plt.legend()
plt.show()

# criando o modelo usando os par√¢metros ajustados
def gaussian_model(X):
    X = data_to_days(X)
    y = 7078.134 * np.exp( -(X-222.597)**2 / (2*56.703**2) )
    return int(y)

tomorrow = datetime.today() + timedelta(days=1)
after_tomorrow = datetime.today() + timedelta(days=120 )

print("Amanh√£:", gaussian_model(tomorrow))
print("Em 120 dias:", gaussian_model(after_tomorrow))

#CONCLUS√ÉO: MODELO SE DEMONSTROU INEFICAZ PARA PREVER O TOTAL DE NOVOS CASOS

"""### *4*-Gaussian Naive Bayes (1) #"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy import optimize

# Supondo que dfTEST_amostra j√° esteja definido e que 'DATAHORA' seja o √≠ndice em formato datetime
# Primeiro, vamos garantir que o √≠ndice est√° em formato datetime
dfTEST_amostra.index = pd.to_datetime(dfTEST_amostra.index)

# Segmentando os dados de acordo com os per√≠odos de treinamento e teste
train_data = dfTEST_amostra[df_train_start:df_train_end]
test_data = dfTEST_amostra[df_test_start:df_test_end]

# Convertendo datas em n√∫meros para a otimiza√ß√£o
X_train = np.arange(len(train_data))
y_train = train_data["total"].values

# Ajustando a fun√ß√£o gaussiana apenas aos dados de treinamento
popt, pcov = optimize.curve_fit(gaussian_func, X_train, y_train)

# Preparando o dom√≠nio da fun√ß√£o para incluir o per√≠odo de previs√£o
X_full = np.arange(len(dfTEST_amostra) + (pd.to_datetime(df_prev_end) - pd.to_datetime(df_prev_start)).days + 1)

# Calculando as previs√µes para todo o per√≠odo (treinamento, teste e previs√£o)
y_full = gaussian_func(X_full, *popt)

# Plotando os resultados
plt.figure(figsize=(14, 7))

# Dados de treinamento
plt.plot(train_data.index, y_train, 'b-', label='Dados de Treino')

# Dados de teste
plt.plot(test_data.index, test_data["total"].values, 'r-', label='Dados de Teste')

# Previs√µes futuras
future_dates = pd.date_range(start=df_prev_start, end=df_prev_end, freq='D')
plt.plot(future_dates, y_full[-len(future_dates):], 'g--', label='Previs√£o Futura')

# Adicionando t√≠tulo e r√≥tulos
plt.title('Previs√£o com Gaussiano: Treinamento, Teste e Previs√£o Futura')
plt.xlabel('Data')
plt.ylabel('Total de Casos')
plt.legend()

# Ajustando as marca√ß√µes do eixo x para melhor visualiza√ß√£o
plt.xticks(rotation=45)
plt.tight_layout()

# Exibindo o gr√°fico
plt.show()

"""### 5-Prophet (v.1)"""

# Preparando os dados para o Prophet
# O Prophet requer que o DataFrame tenha uma coluna 'ds' para datas e uma coluna 'y' para valores
df_prophet = train_data.reset_index().rename(columns={'DATAHORA': 'ds', 'total': 'y'})

# Inicializando o modelo Prophet
model_prophet = Prophet(yearly_seasonality=True, daily_seasonality=True)
model_prophet.fit(df_prophet)

# Criando um DataFrame para as previs√µes futuras
future = model_prophet.make_future_dataframe(periods=(pd.to_datetime(df_prev_end) - pd.to_datetime(df_prev_start)).days)
forecast = model_prophet.predict(future)

# Plotando os resultados
model_prophet.plot(forecast)
plt.title('Previs√£o com Prophet v.1: Treinamento, Teste e Previs√£o Futura')
plt.xlabel('Data')
plt.ylabel('Total de Casos')
plt.show()

from prophet import Prophet
import matplotlib.pyplot as plt
import pandas as pd
from datetime import datetime, timedelta

# Supondo que dfTEST_amostra j√° esteja definido e que 'DATAHORA' seja o √≠ndice em formato datetime
# Primeiro, vamos garantir que o √≠ndice est√° em formato datetime
dfTEST_amostra.index = pd.to_datetime(dfTEST_amostra.index)

# Definindo os per√≠odos de treinamento e teste
# Per√≠odo de treinamento
df_train_start = '2020-01-01' #data de in√≠cio do treinamento
df_train_end = '2022-12-31'   #data de fim do treinamento

# Per√≠odo de teste
df_test_start = '2023-01-01'  #data de in√≠cio do teste
df_test_end = '2023-06-30'    #data de fim do teste

# Per√≠odo de previs√£o
df_prev_start = '2023-07-01'  #data de in√≠cio da previs√£o
df_prev_end = '2023-12-31'    #data de fim da previs√£o



# Segmentando os dados de acordo com os per√≠odos de treinamento e teste
train_data = dfTEST_amostra[df_train_start:df_train_end]
test_data = dfTEST_amostra[df_test_start:df_test_end]

# Preparando os dados para o Prophet
df_prophet = train_data.reset_index().rename(columns={'DATAHORA': 'ds', 'total': 'y'})

# Inicializando o modelo Prophet
model_prophet = Prophet(yearly_seasonality=True, daily_seasonality=True)
model_prophet.fit(df_prophet)

# Criando um DataFrame para as previs√µes futuras
future = model_prophet.make_future_dataframe(periods=(pd.to_datetime(df_prev_end) - pd.to_datetime(df_prev_start)).days)
forecast = model_prophet.predict(future)

# Encontrando as previs√µes futuras
future_predictions = forecast.set_index('ds')[['yhat']].join(dfTEST_amostra, how='left')

# Plotando os resultados
plt.figure(figsize=(14, 7))

# Dados de treinamento
plt.plot(train_data.index, train_data['total'], 'b-', label='Dados de Treino')

# Dados de teste
plt.plot(test_data.index, test_data['total'], 'r-', label='Dados de Teste')

# Previs√µes futuras
plt.plot(future_predictions.index, future_predictions['yhat'], 'g--', label='Previs√£o Futura')

plt.title('Previs√£o com Prophet v.1: Treinamento, Teste e Previs√£o Futura')
plt.xlabel('Data')
plt.ylabel('Total de Casos')
plt.legend()
plt.show()

"""### 5-Prophet (v.2)"""

from prophet import Prophet
import matplotlib.pyplot as plt
import pandas as pd

# Supondo que dfTEST_amostra j√° esteja definido e que 'DATAHORA' seja o √≠ndice em formato datetime
dfTEST_amostra.index = pd.to_datetime(dfTEST_amostra.index)

# Definindo os per√≠odos de treinamento e teste
df_train_start = '2020-01-01'  # Data de in√≠cio do treinamento
df_train_end = '2022-12-31'    # Data de fim do treinamento
df_test_start = '2023-01-01'   # Data de in√≠cio do teste
df_test_end = '2023-06-30'     # Data de fim do teste

# Per√≠odo de previs√£o
df_prev_start = '2023-07-01'   # Data de in√≠cio da previs√£o
df_prev_end = '2023-12-31'     # Data de fim da previs√£o

# Segmentando os dados de acordo com os per√≠odos de treinamento e teste
train_data = dfTEST_amostra[df_train_start:df_train_end]
test_data = dfTEST_amostra[df_test_start:df_test_end]

# Preparando os dados para o Prophet
df_prophet = train_data.reset_index().rename(columns={'DATAHORA': 'ds', 'total': 'y'})

# Inicializando o modelo Prophet
model_prophet = Prophet(yearly_seasonality=True, daily_seasonality=True)
model_prophet.fit(df_prophet)

# Criando um DataFrame para as previs√µes futuras
future = model_prophet.make_future_dataframe(periods=(pd.to_datetime(df_prev_end) - pd.to_datetime(df_test_end)).days)
forecast = model_prophet.predict(future)

# Filtrando as previs√µes futuras para o per√≠odo de previs√£o
forecast_filtered = forecast.set_index('ds').loc[df_prev_start:df_prev_end]

# Plotando os resultados
plt.figure(figsize=(14, 7))

# Dados de treinamento
plt.plot(train_data.index, train_data['total'], 'b-', label='Dados de Treino')

# Dados de teste
plt.plot(test_data.index, test_data['total'], 'r-', label='Dados de Teste')

# Previs√µes futuras
plt.plot(forecast_filtered.index, forecast_filtered['yhat'], 'g--', label='Previs√£o Futura')

plt.title('Previs√£o com Prophet v.2: Treinamento, Teste e Previs√£o Futura')
plt.xlabel('Data')
plt.ylabel('Total de Casos')
plt.legend()
plt.show()

"""### 6-Modelo preditivo com Regress√£o Linear"""

from sklearn.linear_model import LinearRegression
import matplotlib.dates as mdates
import matplotlib.pyplot as plt
import pandas as pd
from datetime import datetime, timedelta

# Supondo que dfTEST_amostra j√° esteja definido e que 'DATAHORA' seja o √≠ndice em formato datetime
dfTEST_amostra.index = pd.to_datetime(dfTEST_amostra.index)

# Definindo os per√≠odos de treinamento e teste
df_train_start = '2020-01-01'  # Data de in√≠cio do treinamento
df_train_end = '2022-12-31'    # Data de fim do treinamento
df_test_start = '2023-01-01'   # Data de in√≠cio do teste
df_test_end = '2023-06-30'     # Data de fim do teste

# Per√≠odo de previs√£o
df_prev_start = '2023-07-01'   # Data de in√≠cio da previs√£o
df_prev_end = '2023-12-31'     # Data de fim da previs√£o

# Segmentando os dados de acordo com os per√≠odos de treinamento e teste
train_data = dfTEST_amostra[df_train_start:df_train_end]
test_data = dfTEST_amostra[df_test_start:df_test_end]

# Preparando os dados para regress√£o linear
X_train_lr = mdates.date2num(train_data.index)  # Convertendo datas em formato num√©rico
X_train_lr = X_train_lr.reshape(-1, 1)
y_train_lr = train_data['total'].values

# Inicializando e treinando o modelo de regress√£o linear
model_lr = LinearRegression()
model_lr.fit(X_train_lr, y_train_lr)

# Preparando os dados para previs√£o futura
future_dates_lr = pd.date_range(start=df_prev_start, end=df_prev_end, freq='D')
future_dates_num_lr = mdates.date2num(future_dates_lr).reshape(-1, 1)

# Fazendo previs√µes
predictions_lr = model_lr.predict(future_dates_num_lr)

# Plotando os resultados da regress√£o linear
plt.figure(figsize=(14, 7))
plt.plot(train_data.index, y_train_lr, 'b-', label='Dados de Treino')
plt.plot(test_data.index, test_data['total'].values, 'r-', label='Dados de Teste')
plt.plot(future_dates_lr, predictions_lr, 'g--', label='Previs√£o Futura')

plt.title('Previs√£o com Modelo de Regress√£o Linear: Treinamento, Teste e Previs√£o Futura')
plt.xlabel('Data')
plt.ylabel('Total de Casos')
plt.legend()
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

"""### 7-Modelo de Suaviza√ß√£o Exponencial (Holt-Winters)"""

import pandas as pd
import matplotlib.pyplot as plt
from statsmodels.tsa.holtwinters import ExponentialSmoothing

# Supondo que dfTEST_amostra j√° esteja definido e que 'DATAHORA' seja o √≠ndice em formato datetime
dfTEST_amostra.index = pd.to_datetime(dfTEST_amostra.index)

# Definindo os per√≠odos de treinamento e teste
df_train_start = '2020-01-01'  # Data de in√≠cio do treinamento
df_train_end = '2022-12-31'    # Data de fim do treinamento
df_test_start = '2023-01-01'   # Data de in√≠cio do teste
df_test_end = '2023-06-30'     # Data de fim do teste

# Per√≠odo de previs√£o
df_prev_start = '2023-07-01'   # Data de in√≠cio da previs√£o
df_prev_end = '2023-12-31'     # Data de fim da previs√£o

# Segmentando os dados de acordo com os per√≠odos de treinamento e teste
train_data = dfTEST_amostra[df_train_start:df_train_end]
test_data = dfTEST_amostra[df_test_start:df_test_end]

# Aplicando o modelo de Suaviza√ß√£o Exponencial (Holt-Winters)
model_hw = ExponentialSmoothing(train_data['total'], seasonal_periods=12, trend='add', seasonal='add')
model_hw_fit = model_hw.fit()

# Gerando datas para previs√£o
future_dates = pd.date_range(start=df_prev_start, end=df_prev_end)

# Previs√µes para o per√≠odo futuro
future_predictions = model_hw_fit.predict(start=future_dates[0], end=future_dates[-1])

# Plotando os resultados
plt.figure(figsize=(14, 7))

# Dados de treinamento
plt.plot(train_data.index, train_data['total'], 'b-', label='Dados de Treino')

# Dados de teste
plt.plot(test_data.index, test_data['total'], 'r-', label='Dados de Teste')

# Previs√µes futuras
plt.plot(future_dates, future_predictions, 'g--', label='Previs√µes Futuras')

plt.title('Previs√£o com Holt-Winters: Treinamento, Teste e Previs√£o Futura')
plt.xlabel('Data')
plt.ylabel('Total de Casos')
plt.legend()
plt.show()

"""### 8-XGBoost"""

import pandas as pd
import xgboost as xgb
import matplotlib.pyplot as plt
from sklearn.model_selection import train_test_split
from sklearn.metrics import mean_squared_error

# Supondo que dfTEST_amostra j√° esteja definido e que 'DATAHORA' seja o √≠ndice em formato datetime
dfTEST_amostra.index = pd.to_datetime(dfTEST_amostra.index)

# Adicionando caracter√≠sticas temporais
dfTEST_amostra['year'] = dfTEST_amostra.index.year
dfTEST_amostra['month'] = dfTEST_amostra.index.month
dfTEST_amostra['day'] = dfTEST_amostra.index.day
dfTEST_amostra['dayofweek'] = dfTEST_amostra.index.dayofweek

# Definindo os per√≠odos de treinamento e teste
df_train_start = '2020-01-01'  # Data de in√≠cio do treinamento
df_train_end = '2022-12-31'    # Data de fim do treinamento
df_test_start = '2023-01-01'   # Data de in√≠cio do teste
df_test_end = '2023-06-30'     # Data de fim do teste

# Segmentando os dados de acordo com os per√≠odos de treinamento e teste
train_data = dfTEST_amostra[df_train_start:df_train_end]
test_data = dfTEST_amostra[df_test_start:df_test_end]

# Preparando dados para o XGBoost
X_train = train_data.drop('total', axis=1)
y_train = train_data['total']
X_test = test_data.drop('total', axis=1)
y_test = test_data['total']

# Criando o modelo XGBoost
model_xgb = xgb.XGBRegressor(objective ='reg:squarederror', colsample_bytree = 0.3, learning_rate = 0.1,
                             max_depth = 5, alpha = 10, n_estimators = 10)

# Treinando o modelo
model_xgb.fit(X_train, y_train)

# Preparando dados para o per√≠odo de previs√£o
future_dates = pd.date_range(start='2023-07-01', end='2023-12-31')
future_df = pd.DataFrame(future_dates, columns=['date'])
future_df['date'] = pd.to_datetime(future_df['date'])
future_df.set_index('date', inplace=True)
future_df['year'] = future_df.index.year
future_df['month'] = future_df.index.month
future_df['day'] = future_df.index.day
future_df['dayofweek'] = future_df.index.dayofweek

# Realizando previs√µes para o per√≠odo futuro
future_predictions = model_xgb.predict(future_df)

# Plotando os resultados
plt.figure(figsize=(14, 7))

# Dados de treinamento
plt.plot(train_data.index, train_data['total'], 'b-', label='Dados de Treino')

# Dados de teste
plt.plot(test_data.index, test_data['total'], 'r-', label='Dados de Teste')

# Previs√µes futuras
plt.plot(future_dates, future_predictions, 'g--', label='Previs√µes Futuras do XGBoost')

plt.title('Previs√£o com XGBoost: Treinamento, Teste e Previs√£o Futura')
plt.xlabel('Data')
plt.ylabel('Total de Casos')
plt.legend()
plt.show()

"""### 9-LightGBM"""

import pandas as pd
import lightgbm as lgb
import matplotlib.pyplot as plt
from sklearn.metrics import mean_squared_error

# Supondo que dfTEST_amostra j√° esteja definido e que 'DATAHORA' seja o √≠ndice em formato datetime
dfTEST_amostra.index = pd.to_datetime(dfTEST_amostra.index)

# Adicionando caracter√≠sticas temporais
dfTEST_amostra['year'] = dfTEST_amostra.index.year
dfTEST_amostra['month'] = dfTEST_amostra.index.month
dfTEST_amostra['day'] = dfTEST_amostra.index.day
dfTEST_amostra['dayofweek'] = dfTEST_amostra.index.dayofweek

# Definindo os per√≠odos de treinamento e teste
df_train_start = '2020-01-01'  # Data de in√≠cio do treinamento
df_train_end = '2022-12-31'    # Data de fim do treinamento
df_test_start = '2023-01-01'   # Data de in√≠cio do teste
df_test_end = '2023-06-30'     # Data de fim do teste

# Segmentando os dados de acordo com os per√≠odos de treinamento e teste
train_data = dfTEST_amostra[df_train_start:df_train_end]
test_data = dfTEST_amostra[df_test_start:df_test_end]

# Preparando dados para o LightGBM
X_train = train_data.drop('total', axis=1)
y_train = train_data['total']
X_test = test_data.drop('total', axis=1)
y_test = test_data['total']

# Criando o modelo LightGBM
model_lgb = lgb.LGBMRegressor(objective='regression', num_leaves=31, learning_rate=0.05, n_estimators=100)

# Treinando o modelo com valida√ß√£o cruzada e parada antecipada
model_lgb.fit(X_train, y_train,
              eval_set=[(X_test, y_test)],
              eval_metric='l2',
              callbacks=[lgb.early_stopping(stopping_rounds=5)])

# Preparando dados para o per√≠odo de previs√£o
future_dates = pd.date_range(start='2023-07-01', end='2023-12-31')
future_df = pd.DataFrame(future_dates, columns=['date'])
future_df['date'] = pd.to_datetime(future_df['date'])
future_df.set_index('date', inplace=True)
future_df['year'] = future_df.index.year
future_df['month'] = future_df.index.month
future_df['day'] = future_df.index.day
future_df['dayofweek'] = future_df.index.dayofweek

# Realizando previs√µes para o per√≠odo futuro
future_predictions = model_lgb.predict(future_df)

# Plotando os resultados
plt.figure(figsize=(14, 7))

# Dados de treinamento
plt.plot(train_data.index, train_data['total'], 'b-', label='Dados de Treino')

# Dados de teste
plt.plot(test_data.index, test_data['total'], 'r-', label='Dados de Teste')

# Previs√µes futuras
plt.plot(future_dates, future_predictions, 'g--', label='Previs√µes Futuras do LightGBM')

plt.title('Previs√£o com LightGBM: Treinamento, Teste e Previs√£o Futura')
plt.xlabel('Data')
plt.ylabel('Total de Casos')
plt.legend()
plt.show()

"""### <h2>10- Modelagem usando SIGMOID (v.1)</h2>

"""

# func√£o sigmoid com par√¢metros a, b, c e d
def sigmoid_func(X, a, b, c, d):
    y =  a / (1 + np.exp( -(X - b) / c)) ** d
    return y

# otimiza√ß√£o usando scipy
popt, pcov = optimize.curve_fit(sigmoid_func, np.arange(len(dfTEST_amostra["total"])), dfTEST_amostra["total"].values)

# gr√°fico
plt.figure(figsize=(15, 6))
plt.title('Modelo Sigm√≥ide v.1: Treinamento, Teste e Previs√£o')
plt.plot(np.arange(len(dfTEST_amostra["total"])), sigmoid_func(np.arange(len(dfTEST_amostra["total"])), *popt), 'g--',
         label='fit: a=%5.3f, b=%5.3f, c=%5.3f d=%5.3f' % tuple(popt))
plt.plot(np.arange(len(dfTEST_amostra["total"])), dfTEST_amostra["total"].values)
plt.xlabel('x')
plt.ylabel('y')
plt.legend()
plt.show()

# criando o modelo usando os par√¢metros ajustados
def sigmoid_model(X):
    X = data_to_days(X)
    y =  577.564 / (1 + np.exp( -(X - 92.688) / 3.301)) ** 0.167
    return int(y)

tomorrow = datetime.today() + timedelta(days=1)
after_tomorrow = datetime.today() + timedelta(days=120)

print("Amanh√£:", sigmoid_model(tomorrow))
print("Em 120 dias:", sigmoid_model(after_tomorrow))

"""CONCLUS√ÉO: O MODELO N√ÉO SE DEMONSTROU EFICAZ, MESMO AJUSTANDO OS PARAMETROS PARA SE APROXIMAR DOS DADOS REAIS

### <h2>10- Modelagem usando SIGMOID (v.2)</h2>
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from scipy import optimize

# Fun√ß√£o sigm√≥ide para ajuste
def sigmoid_func(x, a, b, c):
    return c / (1 + np.exp(-(x-b)/a))

# Supondo que dfTEST_amostra, df_train_start, df_train_end, df_test_start, df_test_end, df_prev_start, df_prev_end estejam definidos

# Convertendo o √≠ndice para datetime
dfTEST_amostra.index = pd.to_datetime(dfTEST_amostra.index)

# Segmentando os dados
train_data = dfTEST_amostra[df_train_start:df_train_end]
test_data = dfTEST_amostra[df_test_start:df_test_end]

# Convertendo datas em n√∫meros para a otimiza√ß√£o
X_train = np.arange(len(train_data))
y_train = train_data["total"].values

# Ajustando a fun√ß√£o sigm√≥ide apenas aos dados de treinamento
popt, pcov = optimize.curve_fit(sigmoid_func, X_train, y_train, p0=[1, np.median(X_train), max(y_train)])

# Preparando o dom√≠nio da fun√ß√£o para incluir o per√≠odo de previs√£o
X_full = np.arange(len(dfTEST_amostra) + (pd.to_datetime(df_prev_end) - pd.to_datetime(df_prev_start)).days + 1)

# Calculando as previs√µes para todo o per√≠odo
y_full = sigmoid_func(X_full, *popt)

# Plotando os resultados
plt.figure(figsize=(14, 7))
plt.plot(train_data.index, y_train, 'b-', label='Dados de Treino')
plt.plot(test_data.index, test_data["total"].values, 'r-', label='Dados de Teste')

# Previs√µes futuras
future_dates = pd.date_range(start=df_prev_start, end=df_prev_end, freq='D')
plt.plot(future_dates, y_full[-len(future_dates):], 'g--', label='Previs√£o Futura')

plt.title('Modelo Sigm√≥ide v.2: Treinamento, Teste e Previs√£o')
plt.xlabel('Data')
plt.ylabel('Total de Casos')
plt.legend()
plt.xticks(rotation=45)
plt.tight_layout()
plt.show()

"""### <h2>10- LSTM com Camada SIGMOID</h2>

"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense
from tensorflow.keras.optimizers import Adam

# Supondo que dfTEST_amostra j√° esteja definido e que 'DATAHORA' seja o √≠ndice em formato datetime
dfTEST_amostra.index = pd.to_datetime(dfTEST_amostra.index)
data = dfTEST_amostra['total']

# Definindo os per√≠odos de treinamento e teste
df_train_start = '2020-01-01'  # Data de in√≠cio do treinamento
df_train_end = '2021-12-31'    # Data de fim do treinamento
df_test_start = '2022-01-01'   # Data de in√≠cio do teste
df_test_end = '2023-06-30'     # Data de fim do teste

# Segmentando os dados
train_data = data[df_train_start:df_train_end]
test_data = data[df_test_start:df_test_end]

# Normalizando os dados
scaler = MinMaxScaler(feature_range=(0, 1))
scaled_train_data = scaler.fit_transform(train_data.values.reshape(-1, 1))

# Fun√ß√£o para criar sequ√™ncias de dados
def create_dataset(data, time_step=1):
    X, Y = [], []
    for i in range(len(data) - time_step):
        a = data[i:(i + time_step), 0]
        X.append(a)
        Y.append(data[i + time_step, 0])
    return np.array(X), np.array(Y)

time_step = 5
X_train, y_train = create_dataset(scaled_train_data, time_step)
X_train = X_train.reshape(X_train.shape[0], X_train.shape[1], 1)  # Reshape para [samples, time_steps, features]

# Criando o modelo LSTM
model = Sequential()
model.add(LSTM(50, return_sequences=True, input_shape=(time_step, 1)))
model.add(LSTM(50, return_sequences=False))
model.add(Dense(25))
model.add(Dense(1, activation='sigmoid'))

# Compilando o modelo
model.compile(optimizer=Adam(learning_rate=0.01), loss='mean_squared_error')

# Treinando o modelo
model.fit(X_train, y_train, epochs=100, batch_size=64, verbose=1)

# Preparando dados para o per√≠odo de previs√£o
df_prev_start = '2023-07-01'   # Data de in√≠cio da previs√£o
df_prev_end = '2024-12-31'     # Data de fim da previs√£o
future_dates = pd.date_range(start=df_prev_start, end=df_prev_end)

# Ajustando o conjunto de dados para previs√£o
# Estendemos os dados para incluir o n√∫mero necess√°rio de entradas para o modelo
extended_data = np.append(scaled_train_data.flatten(), scaler.transform(test_data.values.reshape(-1, 1)).flatten())
X_extended, _ = create_dataset(np.expand_dims(extended_data, axis=1), time_step)
X_future = X_extended[-len(future_dates):]  # Usando apenas os √∫ltimos pontos necess√°rios para a previs√£o
X_future = X_future.reshape(X_future.shape[0], X_future.shape[1], 1)

# Previs√µes para o per√≠odo futuro
future_predictions = model.predict(X_future)
future_predictions = scaler.inverse_transform(future_predictions)

# Plotando os resultados
plt.figure(figsize=(14, 7))
plt.plot(data.index, data, 'b-', label='Dados Originais')
plt.plot(test_data.index, test_data, 'r-', label='Dados de Teste')
plt.plot(future_dates, future_predictions, 'g--', label='Previs√µes Futuras do LSTM')
plt.title('Modelo LSTM com Camada SIGMOID para Previs√£o de S√©ries Temporais')
plt.xlabel('Data')
plt.ylabel('Total de Casos')
plt.legend()
plt.show()

"""### <h2>10- Modelagem usando SIGMOID (v.3)</h2>

"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense
from tensorflow.keras.optimizers import Adam

# Supondo que dfTEST_amostra j√° esteja definido e que 'DATAHORA' seja o √≠ndice em formato datetime
dfTEST_amostra.index = pd.to_datetime(dfTEST_amostra.index)
data = dfTEST_amostra['total']

# Normalizando os dados
scaler = MinMaxScaler(feature_range=(0, 1))
scaled_data = scaler.fit_transform(data.values.reshape(-1, 1))

# Dividindo os dados em treino e teste
train_data = scaled_data[data.index <= pd.to_datetime(df_train_end)]
test_data = scaled_data[(data.index >= pd.to_datetime(df_test_start)) & (data.index <= pd.to_datetime(df_test_end))]

# Criando o modelo com camada SIGMOID
model = Sequential()
model.add(Dense(50, input_dim=1, activation='relu'))
model.add(Dense(1, activation='sigmoid'))

# Compilando o modelo
model.compile(optimizer=Adam(learning_rate=0.01), loss='mean_squared_error')

# Treinando o modelo
model.fit(train_data[:-1], train_data[1:], epochs=100, batch_size=32, verbose=1)

# Fazendo previs√µes
test_predictions = scaler.inverse_transform(model.predict(test_data[:-1]))

# Ajustando os √≠ndices para as previs√µes dos dados de teste
test_dates = data.index[(len(train_data)+1):(len(train_data) + len(test_data))]

# Previs√µes para o per√≠odo futuro
n_future_steps = (pd.to_datetime(df_prev_end) - pd.to_datetime(df_prev_start)).days + 1
future_dates = pd.date_range(start=df_prev_start, end=df_prev_end)
future_predictions = scaler.inverse_transform(model.predict(scaled_data[-n_future_steps-1:-1]))

# Plotando os resultados
plt.figure(figsize=(14, 7))
plt.plot(data.index, data, 'b-', label='Dados Originais')
plt.plot(test_dates, test_predictions, 'r-', label='Previs√µes para Dados de Teste')
plt.plot(future_dates, future_predictions, 'g--', label='Previs√µes Futuras com SIGMOID')
plt.title('Modelo Neural com Camada SIGMOID para Previs√£o de S√©ries Temporais')
plt.title('Modelo Sigm√≥ide v.3 como Camada de Modelo Neural: Treinamento, Teste e Previs√£o')
plt.xlabel('Data')
plt.ylabel('Total de Casos')
plt.legend()
plt.show()